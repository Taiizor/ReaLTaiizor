<?xml version="1.0"?>
<doc>
    <assembly>
        <name>System.Windows.Forms.Primitives</name>
    </assembly>
    <members>
        <member name="F:Interop.ComCtl32.HDI.WIDTH">
            <summary>
            The <c>cxy</c> member is valid and specifies the item's width.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.HDI.HEIGHT">
            <summary>
            The same as <see cref="F:Interop.ComCtl32.HDI.WIDTH"/>.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.HDI.TEXT">
            <summary>
            The <c>pszText</c> and <c>cchTextMax</c> members are valid.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.HDI.FORMAT">
            <summary>
            The <c>fmt</c> member is valid.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.HDI.LPARAM">
            <summary>
            The <c>lParam</c> member is valid.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.HDI.BITMAP">
            <summary>
            The <c>hbm</c> member is valid.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.HDI.IMAGE">
            <summary>
            The <c>iImage</c> member is valid and specifies the image to be displayed with the item.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.HDI.DI_SETITEM">
            <summary>
            While handling the message <c>HDM_GETITEM</c>, the header control may not
            have all the values needed to complete the request.
            In this case, the control must call the application back for the values
            via the <c>HDN_GETDISPINFO</c> notification. If <c>DI_SETITEM</c> has been passed
            in the <c>HDM_GETITEM</c> message, the control will cache any values
            returned from <c>HDN_GETDISPINFO</c> (otherwise the values remain unset.)
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.HDI.ORDER">
            <summary>
            The <c>iOrder</c> member is valid and specifies the item's order value.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.HDI.FILTER">
            <summary>
            The <c>type</c> and <c>pvFilter</c> members are valid.
            This is used to filter out the values specified in the type member.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.HDI.STATE">
            <summary>
            The <c>state</c> member is valid.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVCF.FMT">
            <summary>
            The <c>fmt</c> member is valid.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVCF.WIDTH">
            <summary>
            The <c>cx</c> member is valid.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVCF.TEXT">
            <summary>
            The <c>pszText</c> member is valid.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVCF.SUBITEM">
            <summary>
            The <c>iSubItem</c> member is valid.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVCF.IMAGE">
            <summary>
            The <c>iImage</c> member is valid.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVCF.ORDER">
            <summary>
            The <c>iOrder </c> member is valid.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVCF.MINWIDTH">
            <summary>
            The <c>cxMin</c> member is valid.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVCF.DEFAULTWIDTH">
            <summary>
            The <c>cxDefault</c> member is valid.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVCF.IDEALWIDTH">
            <summary>
            The <c>cxIdeal</c> member is valid.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVCFMT.FIXED_WIDTH">
            <summary>
            Can't resize the column
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVCFMT.NO_DPI_SCALE">
            <summary>
            If not set, CCM_DPISCALE will govern scaling up fixed width
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVCFMT.FIXED_RATIO">
            <summary>
            Width will augment with the row height
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVCFMT.LINE_BREAK">
            <summary>
            Forces the column to wrap to the top of the next list of columns.
            This flag is <c>ListView</c> specific.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVCFMT.FILL">
            <summary>
            Fills the remainder of the tile area. Might have a title.
            This flag is <c>ListView</c> specific.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVCFMT.WRAP">
            <summary>
            Allows the column to wrap within the remaining space in its list of columns.
            This flag is <c>ListView</c> specific.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVCFMT.NO_TITLE">
            <summary>
            Removes the title from the subitem.
            This flag is <c>ListView</c> specific.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVCFMT.TILE_PLACEMENTMASK">
            <summary>
            Equivalent to a combination of LVCFMT_LINE_BREAK and LVCFMT_FILL.
            This flag is <c>ListView</c> specific.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVCFMT.SPLITBUTTON">
            <summary>
            Column is a split button; same as HDF_SPLITBUTTON
            This flag is <c>ListView</c> specific.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVHT.NOWHERE">
            <summary>
            The position is inside the list-view control's client window, but it is not over a list item.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVHT.ONITEMICON">
            <summary>
            The position is over a list-view item's icon.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVHT.ONITEMLABEL">
            <summary>
            The position is over a list-view item's text.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVHT.ABOVE">
            <summary>
            The position is above the control's client area.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVHT.BELOW">
            <summary>
            The position is below the control's client area.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVHT.TORIGHT">
            <summary>
            The position is to the right of the list-view control's client area.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVHT.TOLEFT">
            <summary>
            The position is to the left of the list-view control's client area.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVHT.ONITEM">
            <summary>
            The position is over a list-view item.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVHT.ONITEMSTATEICON">
            <summary>
            The position is over the state image of a list-view item.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVHT.EX_GROUP_HEADER">
            <summary>
            The point is within the group header.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVHT.EX_GROUP_FOOTER">
            <summary>
            The point is within the group footer.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVHT.EX_GROUP_COLLAPSE">
            <summary>
            The point is within the collapse/expand button of the group.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVHT.EX_GROUP_BACKGROUND">
            <summary>
            The point is within the area of the group where items are displayed.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVHT.EX_GROUP_STATEICON">
            <summary>
            The point is within the state icon of the group.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVHT.EX_GROUP_SUBSETLINK">
            <summary>
            The point is within the subset link of the group.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVHT.EX_GROUP">
            <summary>
            The point is within the area of the group where items are displayed.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVHT.EX_ONCONTENTS">
            <summary>
            The point is within the icon or text content of the item and not on the background.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVHT.EX_FOOTER">
            <summary>
            The point is within the footer of the list-view control.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVIF.TEXT">
            <summary>
            The <c>pszText</c> member is valid or must be set.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVIF.IMAGE">
            <summary>
            The <c>iImage</c> member is valid or must be set.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVIF.PARAM">
            <summary>
            The <c>lParam</c> member is valid or must be set.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVIF.STATE">
            <summary>
            The <c>state</c> member is valid or must be set.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVIF.INDENT">
            <summary>
            The <c>iIndent</c> member is valid or must be set.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVIF.NORECOMPUTE">
            <summary>
            The control will not generate <see cref="F:Interop.ComCtl32.LVN.GETDISPINFOW"/>
            to retrieve text information if it receives an <see cref="F:Interop.ComCtl32.LVM.GETITEMW"/> message.
            Instead, the <c>pszText</c> member will contain <c>LPSTR_TEXTCALLBACK</c>.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVIF.GROUPID">
            <summary>
            The <c>iGroupId</c> member is valid or must be set.
            If this flag is not set when an <see cref="F:Interop.ComCtl32.LVM.INSERTITEMW"/> message is sent,
            the value of <c>iGroupId</c> is assumed to be <c>I_GROUPIDCALLBACK</c>.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVIF.COLUMNS">
            <summary>
            The <c>cColumns</c> member is valid or must be set.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVIF.DI_SETITEM">
            <summary>
            The operating system should store the requested list item information
            and not ask for it again. This flag is used only with the
            <see cref="F:Interop.ComCtl32.LVN.GETDISPINFOW"/> notification code.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVIF.COLFMT">
            <summary>
            The <c>piColFmt</c> member is valid or must be set.
            If this flag is used, the <c>cColumns</c> member is valid or must be set.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVIS.FOCUSED">
            <summary>
            The item has the focus, so it is surrounded by a standard focus rectangle.
            Although more than one item may be selected, only one item can have the focus.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVIS.SELECTED">
            <summary>
            The item is selected. The appearance of a selected item depends on whether
            it has the focus and also on the system colors used for selection.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVIS.CUT">
            <summary>
            The item is marked for a cut-and-paste operation.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVIS.DROPHILITED">
            <summary>
            The item is highlighted as a drag-and-drop target.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVIS.OVERLAYMASK">
            <summary>
            The item's overlay image index is retrieved by a mask.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVIS.STATEIMAGEMASK">
            <summary>
            The item's state image index is retrieved by a mask.
            </summary>
        </member>
        <member name="M:Interop.ComCtl32.LVITEMW.UpdateText(System.ReadOnlySpan{System.Char})">
            <summary>
            Set the new text. The text length is limited by <see cref="F:Interop.ComCtl32.LVITEMW.cchTextMax"/>.
            A value of <see cref="F:Interop.ComCtl32.LVITEMW.cchTextMax"/> will be updated to the length of <paramref name="text"/> + 1.
            </summary>
            <param name="text">The text to set.</param>
        </member>
        <member name="T:Interop.ComCtl32.LVM">
            <summary>
             Messages that the ListView control will respond to.
             Copied form commctrl.h
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVTVIF.AUTOSIZE">
            <summary>
            Size the tiles automatically.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVTVIF.FIXEDWIDTH">
            <summary>
            Apply a fixed width to the tiles.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVTVIF.FIXEDHEIGHT">
            <summary>
            Apply a fixed height to the tiles.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVTVIF.FIXEDSIZE">
            <summary>
            Apply a fixed height and width to the tiles.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.LVTVIF.EXTENDED">
            <summary>
            This flag is not supported and should not be used.
            </summary>
        </member>
        <member name="T:Interop.ComCtl32.MCGIF">
            <summary>
            Represents MonthCalendar Control Grid Info Flags.
            Copied form CommCtrl.h
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCGIF.DATE">
            <summary>
            Represetns MCGIF_DATE const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCGIF.RECT">
            <summary>
            Represents MCGIF_RECT cosnt.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCGIF.NAME">
            <summary>
            Represetns MCGIF_NAME const.
            </summary>
        </member>
        <member name="T:Interop.ComCtl32.MCGIP">
            <summary>
            Represents MonthCalendar control part constants.
            Copied form CommCtrl.h
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCGIP.CALENDARCONTROL">
            <summary>
            Represents MCGIP_CALENDARCONTROL const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCGIP.NEXT">
            <summary>
            Represents MCGIP_NEXT const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCGIP.PREV">
            <summary>
            Represents MCGIP_PREV const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCGIP.FOOTER">
            <summary>
            Represents MCGIP_FOOTER const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCGIP.CALENDAR">
            <summary>
            Represents MCGIP_CALENDAR const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCGIP.CALENDARHEADER">
            <summary>
            Represents MCGIP_CALENDARHEADER const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCGIP.CALENDARBODY">
            <summary>
            Represents MCGIP_CALENDARBODY const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCGIP.CALENDARROW">
            <summary>
            Represents MCGIP_CALENDARROW const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCGIP.CALENDARCELL">
            <summary>
            Represents MCGIP_CALENDARCELL const.
            </summary>
        </member>
        <member name="T:Interop.ComCtl32.MCGRIDINFO">
            <summary>
            MonthCalendar grid info structure.
            Copied form CommCtrl.h
            </summary>
        </member>
        <member name="T:Interop.ComCtl32.MCHITTESTINFO">
            <summary>
            <see href="https://docs.microsoft.com/en-us/windows/win32/api/commctrl/ns-commctrl-mchittestinfo">MCHITTESTINFO structure (Microsoft Docs)</see>
            </summary>
        </member>
        <member name="T:Interop.ComCtl32.MCHT">
            <summary>
            Represents MonthCalendar Control HitTest values.
            Copied form CommCtrl.h
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCHT.TITLE">
            <summary>
            MCHT_TITLE
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCHT.CALENDAR">
            <summary>
            Represents MCHT_CALENDAR const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCHT.TODAYLINK">
            <summary>
            Represents MCHT_TODAYLINK const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCHT.CALENDARCONTROL">
            <summary>
            Represents MCHT_CALENDARCONTROL const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCHT.NEXT">
            <summary>
            Represents MCHT_NEXT const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCHT.PREV">
            <summary>
            Represents MCHT_PREV const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCHT.NOWHERE">
            <summary>
            Represents MCHT_NOWHERE const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCHT.TITLEBK">
            <summary>
            Represents MCHT_TITLEBK const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCHT.TITLEMONTH">
            <summary>
            Represents MCHT_TITLEMONTH const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCHT.TITLEYEAR">
            <summary>
            Represents MCHT_TITLEYEAR const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCHT.TITLEBTNNEXT">
            <summary>
            Represents MCHT_TITLEBTNNEXT const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCHT.TITLEBTNPREV">
            <summary>
            Represents MCHT_TITLEBTNPREV const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCHT.CALENDARBK">
            <summary>
            Represents MCHT_CALENDARBK const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCHT.CALENDARDATE">
            <summary>
            Represents MCHT_CALENDARDATE const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCHT.CALENDARDATENEXT">
            <summary>
            Represents MCHT_CALENDARDATENEXT const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCHT.CALENDARDATEPREV">
            <summary>
            Represents MCHT_CALENDARDATEPREV const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCHT.CALENDARDAY">
            <summary>
            Represents MCHT_CALENDARDAY const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCHT.CALENDARWEEKNUM">
            <summary>
            Represents MCHT_CALENDARWEEKNUM const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCHT.CALENDARDATEMIN">
            <summary>
            Represents MCHT_CALENDARDATEMIN const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCHT.CALENDARDATEMAX">
            <summary>
            Represents MCHT_CALENDARDATEMAX const.
            </summary>
        </member>
        <member name="T:Interop.ComCtl32.MCM">
            <summary>
            Represents MonthCalendar Control Messages.
            Copied form CommCtrl.h
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.FIRST">
            <summary>
            Represents MCM_FIRST const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.GETCURSEL">
            <summary>
            Represents MCM_GETCURSEL const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.SETCURSEL">
            <summary>
            Represents MCM_SETCURSEL const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.GETMAXSELCOUNT">
            <summary>
            Represents MCM_GETMAXSELCOUNT const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.SETMAXSELCOUNT">
            <summary>
            Represents MCM_SETMAXSELCOUNT const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.GETSELRANGE">
            <summary>
            Represents MCM_GETSELRANGE const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.SETSELRANGE">
            <summary>
            Represents MCM_SETSELRANGE const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.GETMONTHRANGE">
            <summary>
            Represents MCM_GETMONTHRANGE const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.SETDAYSTATE">
            <summary>
            Represents MCM_SETDAYSTATE const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.GETMINREQRECT">
            <summary>
            Represents MCM_GETMINREQRECT const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.SETCOLOR">
            <summary>
            Represents MCM_SETCOLOR const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.GETCOLOR">
            <summary>
            Represents MCM_GETCOLOR const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.SETTODAY">
            <summary>
            Represents MCM_SETTODAY const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.GETTODAY">
            <summary>
            Represents MCM_GETTODAY const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.HITTEST">
            <summary>
            Represents MCM_HITTEST const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.SETFIRSTDAYOFWEEK">
            <summary>
            Represents MCM_SETFIRSTDAYOFWEEK const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.GETFIRSTDAYOFWEEK">
            <summary>
            Represents MCM_GETFIRSTDAYOFWEEK const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.GETRANGE">
            <summary>
            Represents MCM_GETRANGE const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.SETRANGE">
            <summary>
            Represents MCM_SETRANGE const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.GETMONTHDELTA">
            <summary>
            Represents MCM_GETMONTHDELTA const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.SETMONTHDELTA">
            <summary>
            Represents MCM_SETMONTHDELTA const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.GETMAXTODAYWIDTH">
            <summary>
            Represents MCM_GETMAXTODAYWIDTH const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.GETCURRENTVIEW">
            <summary>
            Represents MCM_GETCURRENTVIEW const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.GETCALENDARCOUNT">
            <summary>
            Represents MCM_GETCALENDARCOUNT const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.GETCALENDARGRIDINFO">
            <summary>
            Represents MCM_GETCALENDARGRIDINFO const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.GETCALID">
            <summary>
            Represents MCM_GETCALID const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.SETCALID">
            <summary>
            Represents MCM_SETCALID const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.SIZERECTTOMIN">
            <summary>
            Represents MCM_SIZERECTTOMIN const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.SETCALENDARBORDER">
            <summary>
            Represents MCM_SETCALENDARBORDER const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.GETCALENDARBORDER">
            <summary>
            Represents MCM_GETCALENDARBORDER const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCM.SETCURRENTVIEW">
            <summary>
            Represents SETCURRENTVIEW const.
            </summary>
        </member>
        <member name="T:Interop.ComCtl32.MCS">
            <summary>
            Represents MonthCalendar Control styles constatnts.
            Copied form CommCtrl.h
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCS.DAYSTATE">
            <summary>
            Represents MCS_DAYSTATE const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCS.MULTISELECT">
            <summary>
            Represents MCS_MULTISELECT const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCS.WEEKNUMBERS">
            <summary>
            Represents MCS_WEEKNUMBERS const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCS.NOTODAYCIRCLE">
            <summary>
            Represents MCS_NOTODAYCIRCLE const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCS.NOTODAY">
            <summary>
            Represents MCS_NOTODAY const.
            </summary>
        </member>
        <member name="T:Interop.ComCtl32.MCSC">
            <summary>
            Represents MonthCalendar control size and color constants.
            Copied form CommCtrl.h
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCSC.BACKGROUND">
            <summary>
            Represents MCSC_BACKGROUND const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCSC.TEXT">
            <summary>
            Represents MCSC_TEXT const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCSC.TITLEBK">
            <summary>
            Represents MCSC_TITLEBK const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCSC.TITLETEXT">
            <summary>
            Represents MCSC_TITLETEXT const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCSC.MONTHBK">
            <summary>
            Represents MCSC_MONTHBK const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.MCSC.TRAILINGTEXT">
            <summary>
            Represents MCSC_TRAILINGTEXT const.
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TASKDIALOGCONFIG.hwndParent">
            <summary>
              "incorrectly named, this is the owner window, not a parent."
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TASKDIALOGCONFIG.hInstance">
            <summary>
              "used for MAKEINTRESOURCE() strings"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TASKDIALOGCONFIG.cxWidth">
            <summary>
              "width of the Task Dialog's client area in DLU's. If 0, Task Dialog
              will calculate the ideal width."
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDCBF.OK_BUTTON">
            <summary>
              "selected control return value IDOK"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDCBF.YES_BUTTON">
            <summary>
              "selected control return value IDYES"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDCBF.NO_BUTTON">
            <summary>
              "selected control return value IDNO"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDCBF.CANCEL_BUTTON">
            <summary>
              "selected control return value IDCANCEL"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDCBF.RETRY_BUTTON">
            <summary>
              "selected control return value IDRETRY"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDCBF.CLOSE_BUTTON">
            <summary>
              "selected control return value IDCLOSE"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDCBF.ABORT_BUTTON">
            <summary>
              "selected control return value IDABORT"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDCBF.IGNORE_BUTTON">
            <summary>
              "selected control return value IDIGNORE"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDCBF.TRYAGAIN_BUTTON">
            <summary>
              "selected control return value IDTRYAGAIN"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDCBF.CONTINUE_BUTTON">
            <summary>
              "selected control return value IDCONTINUE"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDCBF.HELP_BUTTON">
            <summary>
              "selected control return value IDHELP"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDF.NO_SET_FOREGROUND">
            <summary>
              "Don't call SetForegroundWindow() when activating the dialog"
            </summary>
            <remarks>
            <para>
              This flag has an effect only on Windows NT 6.2 ("Windows 8") and higher.
            </para>
            </remarks>
        </member>
        <member name="F:Interop.ComCtl32.TDF.SIZE_TO_CONTENT">
            <summary>
              "used by ShellMessageBox to emulate MessageBox sizing behavior"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDM.CLICK_BUTTON">
            <summary>
              "wParam = Button ID"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDM.SET_MARQUEE_PROGRESS_BAR">
            <summary>
              "wParam = 0 (nonMarque) wParam != 0 (Marquee)"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDM.SET_PROGRESS_BAR_STATE">
            <summary>
              "wParam = new progress state"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDM.SET_PROGRESS_BAR_RANGE">
            <summary>
              "lParam = MAKELPARAM(nMinRange, nMaxRange)"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDM.SET_PROGRESS_BAR_POS">
            <summary>
              "wParam = new position"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDM.SET_PROGRESS_BAR_MARQUEE">
            <summary>
              "wParam = 0 (stop marquee), wParam != 0 (start marquee),
              lparam = speed (milliseconds between repaints)"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDM.SET_ELEMENT_TEXT">
            <summary>
              "wParam = element (TASKDIALOG_ELEMENTS), lParam = new element text (LPCWSTR)"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDM.CLICK_RADIO_BUTTON">
            <summary>
              "wParam = Radio Button ID"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDM.ENABLE_BUTTON">
            <summary>
              "lParam = 0 (disable), lParam != 0 (enable), wParam = Button ID"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDM.ENABLE_RADIO_BUTTON">
            <summary>
              "lParam = 0 (disable), lParam != 0 (enable), wParam = Radio Button ID"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDM.CLICK_VERIFICATION">
            <summary>
              "wParam = 0 (unchecked), 1 (checked), lParam = 1 (set key focus)"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDM.UPDATE_ELEMENT_TEXT">
            <summary>
              "wParam = element (TASKDIALOG_ELEMENTS), lParam = new element text (LPCWSTR)"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDM.SET_BUTTON_ELEVATION_REQUIRED_STATE">
            <summary>
              "wParam = Button ID, lParam = 0 (elevation not required),
              lParam != 0 (elevation required)"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDM.UPDATE_ICON">
            <summary>
              "wParam = icon element (TASKDIALOG_ICON_ELEMENTS), lParam = new icon
              (hIcon if TDF_USE_HICON_* was set, PCWSTR otherwise)"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDN.BUTTON_CLICKED">
            <summary>
              "wParam = Button ID"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDN.HYPERLINK_CLICKED">
            <summary>
              "lParam = (LPCWSTR)pszHREF"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDN.TIMER">
            <summary>
              "wParam = Milliseconds since dialog created or timer reset"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDN.RADIO_BUTTON_CLICKED">
            <summary>
              "wParam = Radio Button ID"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDN.VERIFICATION_CLICKED">
            <summary>
              "wParam = 1 if checkbox checked, 0 if not, lParam is unused and always 0"
            </summary>
        </member>
        <member name="F:Interop.ComCtl32.TDN.EXPANDO_BUTTON_CLICKED">
            <summary>
              "wParam = 0 (dialog is now collapsed), wParam != 0 (dialog is now expanded)"
            </summary>
        </member>
        <member name="T:Interop.Comdlg32.COLOR">
            <summary>
             Identifiers for the Common Color Dialog
            </summary>
        </member>
        <member name="T:Interop.Gdi32.CreateBitmapScope">
            <summary>
             Helper to scope lifetime of a <see cref="T:Interop.Gdi32.HBITMAP"/> created via <see cref="M:Interop.Gdi32.CreateBitmap(System.Int32,System.Int32,System.UInt32,System.UInt32,System.Void*)"/>
             Deletes the <see cref="T:Interop.Gdi32.HBITMAP"/> (if any) when disposed.
            </summary>
            <remarks>
             Use in a <see langword="using" /> statement. If you must pass this around, always pass
             by <see langword="ref" /> to avoid duplicating the handle and risking a double delete.
            </remarks>
        </member>
        <member name="M:Interop.Gdi32.CreateBitmapScope.#ctor(System.Int32,System.Int32,System.UInt32,System.UInt32,System.Void*)">
            <summary>
             Creates a bitmap using <see cref="M:Interop.Gdi32.CreateBitmap(System.Int32,System.Int32,System.UInt32,System.UInt32,System.Void*)"/>
            </summary>
        </member>
        <member name="M:Interop.Gdi32.CreateBitmapScope.#ctor(Interop.Gdi32.HDC,System.Int32,System.Int32)">
            <summary>
             Creates a bitmap compatible with the given <see cref="T:Interop.Gdi32.HDC"/> via <see cref="M:Interop.Gdi32.CreateCompatibleBitmap(Interop.Gdi32.HDC,System.Int32,System.Int32)"/>
            </summary>
        </member>
        <member name="T:Interop.Gdi32.CreateBrushScope">
            <summary>
             Helper to scope the lifetime of a <see cref="T:Interop.Gdi32.HBRUSH"/>.
            </summary>
            <remarks>
             Use in a <see langword="using" /> statement. If you must pass this around, always pass
             by <see langword="ref" /> to avoid duplicating the handle and risking a double delete.
            </remarks>
        </member>
        <member name="M:Interop.Gdi32.CreateBrushScope.#ctor(System.Drawing.Color)">
            <summary>
             Creates a solid brush based on the <paramref name="color"/> using <see cref="M:Interop.Gdi32.CreateSolidBrush(System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Interop.Gdi32.CreateDC(System.String,System.String,System.String,System.IntPtr)">
            <remarks>
             Use <see cref="M:Interop.Gdi32.DeleteDC(Interop.Gdi32.HDC)"/> when finished with the returned DC.
             Calling with ("DISPLAY", null, null, IntPtr.Zero) will retrieve a DC for the entire desktop.
            </remarks>
        </member>
        <member name="T:Interop.Gdi32.CreateDcScope">
            <summary>
             Helper to scope lifetime of an HDC retrieved via CreateDC/CreateCompatibleDC.
             Deletes the HDC (if any) when disposed.
            </summary>
            <remarks>
             Use in a <see langword="using" /> statement. If you must pass this around, always pass
             by <see langword="ref" /> to avoid duplicating the handle and risking a double delete.
            </remarks>
        </member>
        <member name="M:Interop.Gdi32.CreateDcScope.#ctor(Interop.Gdi32.HDC)">
            <summary>
             Creates a compatible HDC for <paramref name="hdc"/> using <see cref="M:Interop.Gdi32.CreateCompatibleDC(Interop.Gdi32.HDC)"/>.
            </summary>
            <remarks>
             Passing a null HDC will use the current screen.
            </remarks>
        </member>
        <member name="T:Interop.Gdi32.CreatePenScope">
            <summary>
             Helper to scope the lifetime of a <see cref="T:Interop.Gdi32.HPEN"/>.
            </summary>
            <remarks>
             Use in a <see langword="using" /> statement. If you must pass this around, always pass
             by <see langword="ref" /> to avoid duplicating the handle and risking a double delete.
            </remarks>
        </member>
        <member name="M:Interop.Gdi32.CreatePenScope.#ctor(System.Drawing.Color,System.Int32)">
            <summary>
             Creates a solid pen based on the <paramref name="color"/> and <paramref name="width"/> using
             <see cref="M:Interop.Gdi32.CreatePen(Interop.Gdi32.PS,System.Int32,System.Int32)" />.
            </summary>
        </member>
        <member name="T:Interop.Gdi32.ObjectScope">
            <summary>
             Helper to scope lifetime of a GDI object. Deletes the given object (if any) when disposed.
            </summary>
            <remarks>
             Use in a <see langword="using" /> statement. If you must pass this around, always pass
             by <see langword="ref" /> to avoid duplicating the handle and risking a double deletion.
            </remarks>
        </member>
        <member name="M:Interop.Gdi32.ObjectScope.#ctor(Interop.Gdi32.HGDIOBJ)">
            <param name="object">The object to be deleted when the scope closes.</param>
        </member>
        <member name="F:Interop.Gdi32.QUALITY.DEFAULT">
            <summary>
             Appearance of the font does not matter.
            </summary>
        </member>
        <member name="F:Interop.Gdi32.QUALITY.DRAFT">
            <summary>
             Appearance of the font is less important than when PROOF_QUALITY is used.
             For GDI raster fonts, scaling is enabled, which means that more font sizes are available,
             but the quality may be lower. Bold, italic, underline, and strikeout fonts are synthesized if necessary.
            </summary>
        </member>
        <member name="F:Interop.Gdi32.QUALITY.PROOF">
            <summary>
             Character quality of the font is more important than exact matching of the logical-font attributes.
             For GDI raster fonts, scaling is disabled and the font closest in size is chosen.
             Although the chosen font size may not be mapped exactly when PROOF_QUALITY is used, the quality of
             the font is high and there is no distortion of appearance. Bold, italic, underline, and strikeout
             fonts are synthesized if necessary.
            </summary>
        </member>
        <member name="F:Interop.Gdi32.QUALITY.NONANTIALIASED">
            <summary>
             Font is never antialiased.
            </summary>
        </member>
        <member name="F:Interop.Gdi32.QUALITY.ANTIALIASED">
            <summary>
             Font is always antialiased if the font supports it and the size of the font is not
             too small or too large.
            </summary>
        </member>
        <member name="F:Interop.Gdi32.QUALITY.CLEARTYPE">
            <summary>
             The following situations do not support ClearType antialiasing:
             - Text is rendered on a printer.
             - Display set for 256 colors or less.
             - Text is rendered to a terminal server client.
             - The font is not a TrueType font or an OpenType font with TrueType outlines.
             For example, the following do not support ClearType antialiasing:
             Type 1 fonts, Postscript OpenType fonts without TrueType outlines, bitmap fonts, vector fonts, and device fonts.
             - The font has tuned embedded bitmaps, for any font sizes that contain the embedded bitmaps.
             For example, this occurs commonly in East Asian fonts.
             If set, text is rendered (when possible) using ClearType antialiasing method.
            </summary>
        </member>
        <member name="T:Interop.Gdi32.RegionScope">
            <summary>
             Helper to scope creating regions. Deletes the region when disposed.
            </summary>
            <remarks>
             Use in a <see langword="using" /> statement. If you must pass this around, always pass
             by <see langword="ref" /> to avoid duplicating the handle and risking a double deletion.
            </remarks>
        </member>
        <member name="M:Interop.Gdi32.RegionScope.#ctor(System.Drawing.Rectangle)">
            <summary>
             Creates a region with the given rectangle via <see cref="M:Interop.Gdi32.CreateRectRgn(System.Int32,System.Int32,System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Interop.Gdi32.RegionScope.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
             Creates a region with the given rectangle via <see cref="M:Interop.Gdi32.CreateRectRgn(System.Int32,System.Int32,System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Interop.Gdi32.RegionScope.#ctor(Interop.Gdi32.HDC)">
            <summary>
             Creates a clipping region copy via <see cref="M:Interop.Gdi32.GetClipRgn(Interop.Gdi32.HDC,Interop.Gdi32.HRGN)"/> for the given device context.
            </summary>
            <param name="hdc">Handle to a device context to copy the clipping region from.</param>
        </member>
        <member name="M:Interop.Gdi32.RegionScope.#ctor(System.Drawing.Region,System.Drawing.Graphics)">
            <summary>
             Creates a native region from a GDI+ <see cref="P:Interop.Gdi32.RegionScope.Region"/>.
            </summary>
        </member>
        <member name="P:Interop.Gdi32.RegionScope.IsNull">
            <summary>
             Returns true if this represents a null HRGN.
            </summary>
        </member>
        <member name="M:Interop.Gdi32.RegionScope.CreateGdiPlusRegion">
            <summary>
             Creates a GDI+ region for this region.
            </summary>
            <returns>The GDI+ region. Must be disposed.</returns>
        </member>
        <member name="M:Interop.Gdi32.RegionScope.RelinquishOwnership">
            <summary>
             Clears the handle. Use this to hand over ownership to another entity.
            </summary>
        </member>
        <member name="T:Interop.Gdi32.SaveDcScope">
             <summary>
              Helper to scope lifetime of a saved device context state.
             </summary>
             <remarks>
              Use in a <see langword="using" /> statement. If you must pass this around, always pass by <see langword="ref" />
              to avoid duplicating the handle and risking a double restore.
            
              The state that is saved includes ICM (color management), palette, path drawing state, and other objects
              that are selected into the DC (bitmap, brush, pen, clipping region, font).
            
              Ideally saving the entire DC state can be avoided for simple drawing operations and relying on restoring
              individual state pieces can be done instead (putting back the original pen, etc.).
             </remarks>
        </member>
        <member name="M:Interop.Gdi32.SaveDcScope.#ctor(Interop.Gdi32.HDC)">
            <summary>
             Saves the device context state using <see cref="M:Interop.Gdi32.SaveDC(Interop.Gdi32.HDC)"/>.
            </summary>
            <param name="hdc"></param>
        </member>
        <member name="T:Interop.Gdi32.SelectObjectScope">
            <summary>
             Helper to scope selecting a GDI object into an HDC. Restores the original
             object into the HDC when disposed.
            </summary>
            <remarks>
             Use in a <see langword="using" /> statement. If you must pass this around, always pass
             by <see langword="ref" /> to avoid duplicating the handle and risking a double selection.
            </remarks>
        </member>
        <member name="M:Interop.Gdi32.SelectObjectScope.#ctor(Interop.Gdi32.HDC,Interop.Gdi32.HGDIOBJ)">
            <summary>
             Selects <paramref name="object"/> into the given <paramref name="hdc"/> using
             <see cref="M:Interop.Gdi32.SelectObject(Interop.Gdi32.HDC,Interop.Gdi32.HGDIOBJ)"/>.
            </summary>
        </member>
        <member name="T:Interop.Gdi32.SelectPaletteScope">
            <summary>
             Helper to scope palette selection.
            </summary>
            <remarks>
             Use in a <see langword="using" /> statement. If you must pass this around, always pass
             by <see langword="ref" /> to avoid duplicating the handle and risking a double pallete reset.
            </remarks>
        </member>
        <member name="T:Interop.Gdi32.SetBackgroundColorScope">
            <summary>
             Helper to scope selecting a given background color into a HDC. Restores the original background color into
             the HDC when disposed.
            </summary>
            <remarks>
             Use in a <see langword="using" /> statement. If you must pass this around, always pass by
             <see langword="ref" /> to avoid duplicating the handle and resetting multiple times.
            </remarks>
        </member>
        <member name="M:Interop.Gdi32.SetBackgroundColorScope.#ctor(Interop.Gdi32.HDC,System.Drawing.Color)">
            <summary>
             Sets text color <paramref name="color"/> in the given <paramref name="hdc"/> using
             <see cref="M:Interop.Gdi32.SetBkColor(Interop.Gdi32.HDC,System.Int32)"/>.
            </summary>
        </member>
        <member name="T:Interop.Gdi32.SetBkModeScope">
            <summary>
             Helper to scope selecting a given background mix mode into a HDC. Restores the original
             mix mode into the HDC when disposed.
            </summary>
            <remarks>
             Use in a <see langword="using" /> statement. If you must pass this around, always pass by
             <see langword="ref" /> to avoid duplicating the handle and resetting multiple times.
            </remarks>
        </member>
        <member name="M:Interop.Gdi32.SetBkModeScope.#ctor(Interop.Gdi32.HDC,Interop.Gdi32.BKMODE)">
            <summary>
             Selects <paramref name="bkmode"/> into the given <paramref name="hdc"/>.
            </summary>
        </member>
        <member name="T:Interop.Gdi32.SetMapModeScope">
            <summary>
             Helper to scope selecting a given mapping mode into a HDC. Restores the original mapping mode into the HDC
             when disposed.
            </summary>
            <remarks>
             Use in a <see langword="using" /> statement. If you must pass this around, always pass by
             <see langword="ref" /> to avoid duplicating the handle and resetting multiple times.
            </remarks>
        </member>
        <member name="M:Interop.Gdi32.SetMapModeScope.#ctor(Interop.Gdi32.HDC,Interop.Gdi32.MM)">
            <summary>
             Sets the <paramref name="mapMode"/> in the given <paramref name="hdc"/> using
             <see cref="M:Interop.Gdi32.SetMapMode(Interop.Gdi32.HDC,Interop.Gdi32.MM)"/>.
            </summary>
        </member>
        <member name="T:Interop.Gdi32.SetRop2Scope">
            <summary>
             Helper to scope selecting a given foreground mix mode into a HDC. Restores the original mix mode into the
             HDC when disposed.
            </summary>
            <remarks>
             Use in a <see langword="using" /> statement. If you must pass this around, always pass by
             <see langword="ref" /> to avoid duplicating the handle and resetting multiple times.
            </remarks>
        </member>
        <member name="M:Interop.Gdi32.SetRop2Scope.#ctor(Interop.Gdi32.HDC,Interop.Gdi32.R2)">
            <summary>
             Selects <paramref name="rop2"/> into the given <paramref name="hdc"/> using <see cref="M:Interop.Gdi32.SetROP2(Interop.Gdi32.HDC,Interop.Gdi32.R2)"/>.
            </summary>
        </member>
        <member name="T:Interop.Gdi32.SetTextAlignmentScope">
            <summary>
             Helper to scope selecting a given text alignment mode into a HDC. Restores the original text alignment
             mode into the HDC when disposed.
            </summary>
            <remarks>
             Use in a <see langword="using" /> statement. If you must pass this around, always pass by
             <see langword="ref" /> to avoid duplicating the handle and resetting multiple times.
            </remarks>
        </member>
        <member name="M:Interop.Gdi32.SetTextAlignmentScope.#ctor(Interop.Gdi32.HDC,Interop.Gdi32.TA)">
            <summary>
             Sets <paramref name="ta"/> in the given <paramref name="hdc"/> using <see cref="M:Interop.Gdi32.SetTextAlign(Interop.Gdi32.HDC,Interop.Gdi32.TA)"/>.
            </summary>
        </member>
        <member name="T:Interop.Gdi32.SetTextColorScope">
            <summary>
             Helper to scope selecting a given foreground text color into a HDC. Restores the original text color into
             into the HDC when disposed.
            </summary>
            <remarks>
             Use in a <see langword="using" /> statement. If you must pass this around, always pass by
             <see langword="ref" /> to avoid duplicating the handle and resetting multiple times.
            </remarks>
        </member>
        <member name="M:Interop.Gdi32.SetTextColorScope.#ctor(Interop.Gdi32.HDC,System.Drawing.Color)">
            <summary>
             Sets text color <paramref name="color"/> in the given <paramref name="hdc"/> using
             <see cref="M:Interop.Gdi32.SetTextColor(Interop.Gdi32.HDC,System.Int32)"/>.
            </summary>
        </member>
        <member name="T:Interop.Gdi32.StockObject">
            <summary>
             Stock GDI object identifiers.
            </summary>
            <remarks>
             Note that in metafile records these values are OR'ed with 0x80000000.
            </remarks>
        </member>
        <member name="T:Interop.BOOL">
            <summary>
             Blittable version of Windows BOOL type. It is convenient in situations where
             manual marshalling is required, or to avoid overhead of regular bool marshalling.
            </summary>
            <remarks>
             Some Windows APIs return arbitrary integer values although the return type is defined
             as BOOL. It is best to never compare BOOL to TRUE. Always use bResult != BOOL.FALSE
             or bResult == BOOL.FALSE .
            </remarks>
        </member>
        <member name="T:Interop.BOOLEAN">
            <summary>
             Blittable version of Windows BOOLEAN type. It is convenient in situations where
             manual marshalling is required, or to avoid overhead of regular BOOLEAN marshalling.
            </summary>
            <remarks>
             Some Windows APIs return arbitrary integer values although the return type is defined
             as BOOL. It is best to never compare BOOLEAN to TRUE. Always use bResult != BOOLEAN.FALSE
             or bResult == BOOLEAN.FALSE .
            </remarks>
        </member>
        <member name="P:Interop.BSTR.Length">
            <summary>
             Returns the length of the native BSTR.
            </summary>
        </member>
        <member name="T:Interop.PARAM">
            <summary>
             Helpers for creating W/LPARAM arguments for messages.
            </summary>
        </member>
        <member name="M:Interop.PARAM.ToInt(System.IntPtr)">
            <summary>
             Hard casts to <see langword="int" /> without bounds checks.
            </summary>
        </member>
        <member name="M:Interop.PARAM.ToUInt(System.IntPtr)">
            <summary>
             Hard casts to <see langword="uint" /> without bounds checks.
            </summary>
        </member>
        <member name="M:Interop.PARAM.ToLong(System.IntPtr)">
            <summary>
             Hard casts to <see langword="long" /> without bounds checks.
            </summary>
            <remarks>
             Technically not needed, but here for completeness.
            </remarks>
        </member>
        <member name="M:Interop.PARAM.ToULong(System.IntPtr)">
            <summary>
             Hard casts to <see langword="ulong" /> without bounds checks.
            </summary>
        </member>
        <member name="M:Interop.Kernel32.GetProcAddress(System.IntPtr,System.String)">
            <remarks>
             There isn't a unicode version of this API so pass in an ANSI string.
            </remarks>
        </member>
        <member name="T:Interop.Kernel32.ProcessAccessOptions">
            <summary>
            This access right is checked against the security descriptor for the process
            </summary>
        </member>
        <member name="T:Interop.Mso.IMsoComponent">
             <remarks>
              WM_MOUSEACTIVATE Note (for top level compoenents and host)
            
              If the active (or tracking) comp's reg info indicates that it wants mouse
              messages, then no MA_xxxANDEAT value should be returned  from WM_MOUSEACTIVATE,
              so that the active (or tracking) comp will be able to process the resulting mouse
              message. If one does not want to examine the reg info, no MA_xxxANDEAT value
              should be returned from WM_MOUSEACTIVATE if any comp is active (or tracking). One
              can query the reg info  of the active (or tracking) component at any time via
              <see cref="M:Interop.Mso.IMsoComponentManager.FGetActiveComponent(Interop.Mso.msogac,System.Void**,Interop.Mso.MSOCRINFO*,System.UInt32)"/>.
             </remarks>
        </member>
        <member name="M:Interop.Mso.IMsoComponent.FDebugMessage(System.IntPtr,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
             Standard <see cref="M:Interop.Mso.IMsoComponent.FDebugMessage(System.IntPtr,System.UInt32,System.IntPtr,System.IntPtr)"/> method.
            </summary>
            <remarks>
             This method is reserved for internal use and is not intended to be used in your code.
            </remarks>
            <returns><see cref="F:Interop.BOOL.TRUE"/></returns>
        </member>
        <member name="M:Interop.Mso.IMsoComponent.FPreTranslateMessage(Interop.User32.MSG*)">
            <summary>
             Give component a chance to process <paramref name="msg"/> before it is translated
             and dispatched. Component can modify <paramref name="msg"/>, call Win32 APIs such
             as TranslateAccelerator or IsDialogMessage, or take some other action.
            </summary>
            <returns>
             Return <see cref="F:Interop.BOOL.TRUE"/> if the message is consumed,
             <see cref="F:Interop.BOOL.FALSE"/> otherwise.
            </returns>
        </member>
        <member name="M:Interop.Mso.IMsoComponent.OnEnterState(Interop.Mso.msocstate,Interop.BOOL)">
             <summary>
              Notify component when app enters or exits (as indicated by <paramref name="fEnter"/>)
              the state identified by <paramref name="uStateID"/>. Component should take action
              depending on value of <paramref name="uStateID"/> (see olecstate comments, above).
             </summary>
             <remarks>
              Note: If n calls are made with TRUE <paramref name="fEnter"/>, component should consider
              the state to be in effect until n calls are made with FALSE <paramref name="fEnter"/>.
            
              Note: Components should be aware that it is possible for this method to be called
              with FALSE <paramref name="fEnter"/> more times than it was called with TRUE
              <paramref name="fEnter"/> (so, for example, if component is maintaining a state counter
              incremented when this method is called with BOOL.TRUE <paramref name="fEnter"/>,
              decremented when called with FALSE <paramref name="fEnter"/>), the counter should not
              be decremented for FALSE <paramref name="fEnter"/> if it is already at zero.)
             </remarks>
        </member>
        <member name="M:Interop.Mso.IMsoComponent.OnAppActivate(Interop.BOOL,System.UInt32)">
             <summary>
              Notify component when the host application gains or loses activation.
             </summary>
             <remarks>
              Note: this method is not called when both the window being activated and the one being
              deactivated belong to the host app.
             </remarks>
             <param name="fActive">
              If <see cref="F:Interop.BOOL.TRUE"/>, the host app is being activated and <paramref name="dwOtherThreadID"/>
              is the ID of the thread owning the window being deactivated.
            
              If <see cref="F:Interop.BOOL.FALSE"/>, the host app is being deactivated and <paramref name="dwOtherThreadID"/>
              is the ID of the thread owning the window being activated.
             </param>
        </member>
        <member name="M:Interop.Mso.IMsoComponent.OnLoseActivation">
            <summary>
             Notify the active component that it has lost its active status because the host or
             another component has become active.
            </summary>
        </member>
        <member name="M:Interop.Mso.IMsoComponent.OnActivationChange(Interop.Mso.IMsoComponent,Interop.BOOL,Interop.Mso.MSOCRINFO*,Interop.BOOL,System.IntPtr,System.UInt32)">
             <summary>
              Notify component when a new object is being activated.
             </summary>
             <remarks>
              If <paramref name="pic"/> is being activated and <paramref name="pcrinfo"/>
              <see cref="F:Interop.Mso.MSOCRINFO.grfcrf"/> has the <see cref="F:Interop.Mso.msocrf.ExclusiveBorderSpace"/>
              bit set, component should hide its border space tools (toolbars, status bars, etc.);
              component should also do this if host is activating and <paramref name="pchostinfo"/>
              has the <see cref="F:Interop.Mso.msocrf.ExclusiveBorderSpace"/> bit set. In either of these cases,
              component should unhide its border space tools the next time it is activated.
            
              If <paramref name="pic"/> is being activated and <paramref name="pcrinfo"/>
              <see cref="F:Interop.Mso.MSOCRINFO.grfcrf"/> has the <see cref="F:Interop.Mso.msocrf.ExclusiveActivation"/>
              bit set, then <paramref name="pic"/> is being activated in "ExclusiveActive" mode.
              Component should retrieve the top frame window that is hosting <paramref name="pic"/>
              (via <see cref="M:Interop.Mso.IMsoComponent.HwndGetWindow(Interop.Mso.msocWindow,System.UInt32)"/> with <see cref="F:Interop.Mso.msocWindow.FrameToplevel"/>).
            
              If this window is different from component's own top frame window, component should
              disable its windows and do other things it would do when receiving
              <see cref="M:Interop.Mso.IMsoComponent.OnEnterState(Interop.Mso.msocstate,Interop.BOOL)"/> with <see cref="F:Interop.Mso.msocstate.Modal" /> notification.
            
              Otherwise, if component is top-level, it should refuse to have its window activated
              by appropriately processing WM_MOUSEACTIVATE (but see WM_MOUSEACTIVATE NOTE, above).
              Component should remain in one of these states until the exclusive active mode ends,
              indicated by a future call to <see cref="M:Interop.Mso.IMsoComponent.OnActivationChange(Interop.Mso.IMsoComponent,Interop.BOOL,Interop.Mso.MSOCRINFO*,Interop.BOOL,System.IntPtr,System.UInt32)"/> with
              <see cref="F:Interop.Mso.msocrf.ExclusiveActivation" /> bit not set or with null
              <paramref name="pcrinfo"/>.
             </remarks>
             <param name="pic">
              If non-null, then it is the component that is being activated. In this case,
              <paramref name="fSameComponent"/> is TRUE if <paramref name="pic"/> is the same
              component as the callee of this method, and <paramref name="pcrinfo"/> is the
              reg info of <paramref name="pic"/>.
            
              If null and <paramref name="fHostIsActivating"/> is TRUE, then the host is the
              object being activated, and <paramref name="pchostinfo"/> is its host info.
            
              If null and <paramref name="fHostIsActivating"/> is FALSE, then there is no
              current active object.
             </param>
        </member>
        <member name="M:Interop.Mso.IMsoComponent.FDoIdle(Interop.Mso.msoidlef)">
             <summary>
              Give component a chance to do idle time tasks.  grfidlef is a group of
              bit flags taken from the enumeration of <see cref="T:Interop.Mso.msoidlef"/> values,
              indicating the type of idle tasks to perform.
             </summary>
             <remarks>
              Component may periodically call <see cref="M:Interop.Mso.IMsoComponentManager.FContinueIdle"/>;
              if this method returns FALSE, component should terminate its idle time
              processing and return.
            
              Note: If a component reaches a point where it has no idle tasks and does not
              need <see cref="M:Interop.Mso.IMsoComponent.FDoIdle(Interop.Mso.msoidlef)"/> calls, it should remove its idle task registration
              via <see cref="M:Interop.Mso.IMsoComponentManager.FUpdateComponentRegistration(System.UIntPtr,Interop.Mso.MSOCRINFO*)"/>.
            
              Note: If this method is called on while component is performing a tracking
              operation, component should only perform idle time tasks that it deems are
              appropriate to perform during tracking.
             </remarks>
             <returns>
              <see cref="F:Interop.BOOL.TRUE"/> if more time is needed to perform the idle time tasks,
              <see cref="F:Interop.BOOL.FALSE"/> otherwise.
             </returns>
        </member>
        <member name="M:Interop.Mso.IMsoComponent.FContinueMessageLoop(Interop.Mso.msoloop,System.Void*,Interop.User32.MSG*)">
             <summary>
              Called during each iteration of a message loop that the component pushed.
             </summary>
             <remarks>
              This method is called after peeking the next message in the queue (via PeekMessage)
              but before the message is removed from the queue. The peeked message is passed in
              the <paramref name="pMsgPeeked"/> param (null if no message is in the queue).
            
              This method may be additionally called when the next message has already been removed
              from the queue, in which case <paramref name="pMsgPeeked"/> is passed as null.
             </remarks>
             <param name="uReason">
              Reason that was passed to <see cref="M:Interop.Mso.IMsoComponentManager.FPushMessageLoop(System.UIntPtr,Interop.Mso.msoloop,System.Void*)"/>.
             </param>
             <param name="pvLoopData">
              Component private data passed to <see cref="M:Interop.Mso.IMsoComponentManager.FPushMessageLoop(System.UIntPtr,Interop.Mso.msoloop,System.Void*)"/>.
             </param>
             <returns>
              <see cref="F:Interop.BOOL.TRUE"/> if the message loop should continue,
              <see cref="F:Interop.BOOL.FALSE"/> otherwise.
            
              If <see cref="F:Interop.BOOL.FALSE"/> is returned, the component manager terminates the
              loop without removing <paramref name="pMsgPeeked"/> from the queue.
             </returns>
        </member>
        <member name="M:Interop.Mso.IMsoComponent.FQueryTerminate(Interop.BOOL)">
             <summary>
              Called when component manager wishes to know if the component is in a
              state in which it can terminate.
             </summary>
             <remarks>
              If <paramref name="fPromptUser"/> is FALSE, component should simply return
              TRUE if it can terminate, FALSE otherwise.
            
              If <paramref name="fPromptUser"/> is TRUE, component should return TRUE if
              it can terminate without prompting the user; otherwise it should prompt the
              user, either 1.) asking user if it can terminate and returning TRUE or FALSE
              appropriately, or 2.) giving an indication as to why it cannot terminate and
              returning FALSE.
             </remarks>
        </member>
        <member name="M:Interop.Mso.IMsoComponent.Terminate">
            <summary>
             Called when component manager wishes to terminate the component's registration.
            </summary>
            <remarks>
             Component should revoke its registration with component manager, release
             references to component manager and perform any necessary cleanup.
            </remarks>
        </member>
        <member name="M:Interop.Mso.IMsoComponent.HwndGetWindow(Interop.Mso.msocWindow,System.UInt32)">
            <summary>
             Called to retrieve a window associated with the component, as specified
             by <paramref name="dwWhich"/>.
            </summary>
            <returns>
             Desired window or null if no such window exists.
            </returns>
            <param name="dwReserved">Reserved for future use and should be zero.</param>
        </member>
        <member name="T:Interop.Mso.IMsoComponentManager">
             <remarks>
              ** Comments on State Contexts **
            
              <see cref="M:Interop.Mso.IMsoComponentManager.FCreateSubComponentManager(System.IntPtr,System.IntPtr,System.Guid*,System.Void**)"/> allows one to create a hierarchical tree of component managers.
              This tree is used to maintain multiple contexts with regard to <see cref="T:Interop.Mso.msocstate"/> states. These
              contexts are referred to as 'state contexts'. Each component manager in the tree defines a state context.
              The components registered with a particular component manager or any of its descendents live within that
              component manager's state context.
            
              Calls to <see cref="M:Interop.Mso.IMsoComponentManager.OnComponentEnterState(System.UIntPtr,Interop.Mso.msocstate,Interop.Mso.msoccontext,System.UInt32,System.Void**,System.UInt32)"/> and <see cref="M:Interop.Mso.IMsoComponentManager.FOnComponentExitState(System.UIntPtr,Interop.Mso.msocstate,Interop.Mso.msoccontext,System.UInt32,System.Void**)"/> can be used to affect
              all components, only components within the component manager's state context, or only those components
              that are outside of the component manager's state context. <see cref="M:Interop.Mso.IMsoComponentManager.FInState(Interop.Mso.msocstate,System.Void*)"/> is used to query the
              state of the component manager's state context at its root.
             </remarks>
        </member>
        <member name="M:Interop.Mso.IMsoComponentManager.QueryService(System.Guid*,System.Guid*,System.Void**)">
            <summary>
             Returns in <paramref name="ppvObj"/> an implementation of interface <paramref name="iid"/>
             for service <paramref name="guidService"/> (same as IServiceProvider::QueryService).
            </summary>
            <param name="ppvObj">The queried interface or null if failed.</param>
            <returns>
             NOERROR if the requested service is supported, otherwise appropriate error such
             as E_FAIL, E_NOINTERFACE.
            </returns>
        </member>
        <member name="M:Interop.Mso.IMsoComponentManager.FDebugMessage(System.IntPtr,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
             Standard <see cref="M:Interop.Mso.IMsoComponentManager.FDebugMessage(System.IntPtr,System.UInt32,System.IntPtr,System.IntPtr)"/> method.
            </summary>
            <remarks>
             This method is reserved for internal use and is not intended to be used in your code.
            </remarks>
            <returns><see cref="F:Interop.BOOL.TRUE"/></returns>
        </member>
        <member name="M:Interop.Mso.IMsoComponentManager.FRegisterComponent(Interop.Mso.IMsoComponent,Interop.Mso.MSOCRINFO*,System.UIntPtr*)">
            <summary>
             Register component <paramref name="piComponent"/> and its registration info
             <paramref name="pcrinfo"/> with this component manager.
            </summary>
            <param name="dwComponentID">
             Returns a cookie which will identify the component when it calls other
             <see cref="T:Interop.Mso.IMsoComponentManager"/> methods.
            </param>
            <returns><see cref="F:Interop.BOOL.TRUE"/> if successful.</returns>
        </member>
        <member name="M:Interop.Mso.IMsoComponentManager.FRevokeComponent(System.UIntPtr)">
            <summary>
             Undo the registration of the component identified by <paramref name="dwComponentID"/>
             (the cookie returned from the <see cref="M:Interop.Mso.IMsoComponentManager.FRegisterComponent(Interop.Mso.IMsoComponent,Interop.Mso.MSOCRINFO*,System.UIntPtr*)"/> method).
            </summary>
            <returns><see cref="F:Interop.BOOL.TRUE"/> if successful.</returns>
        </member>
        <member name="M:Interop.Mso.IMsoComponentManager.FUpdateComponentRegistration(System.UIntPtr,Interop.Mso.MSOCRINFO*)">
            <summary>
             Update the registration info of the component identified by <paramref name="dwComponentID"/>
             (the cookie returned from <see cref="M:Interop.Mso.IMsoComponentManager.FRegisterComponent(Interop.Mso.IMsoComponent,Interop.Mso.MSOCRINFO*,System.UIntPtr*)"/>) with the new registration
             information <paramref name="pcrinfo"/>.
            </summary>
            <remarks>
             Typically this is used to update the idle time registration data, but it can be used to
             update other registration data as well.
            </remarks>
            <returns><see cref="F:Interop.BOOL.TRUE"/> if successful.</returns>
        </member>
        <member name="M:Interop.Mso.IMsoComponentManager.FOnComponentActivate(System.UIntPtr)">
             <summary>
              Notify component manager that component identified by <paramref name="dwComponentID"/>
              (cookie returned from <see cref="M:Interop.Mso.IMsoComponentManager.FRegisterComponent(Interop.Mso.IMsoComponent,Interop.Mso.MSOCRINFO*,System.UIntPtr*)"/>) has been activated.
             </summary>
             <remarks>
              The active component gets the chance to process messages before they are dispatched
              (via <see cref="M:Interop.Mso.IMsoComponent.FPreTranslateMessage(Interop.User32.MSG*)"/> and typically gets first chance
              at idle time after the host.
            
              This method fails if another component is already exclusively active. In this case,
              <see cref="F:Interop.BOOL.FALSE"/> is returned and SetLastError is set to msoerrACompIsXActive
              (comp usually need not take any special action in this case).
             </remarks>
             <returns><see cref="F:Interop.BOOL.TRUE"/> if successful.</returns>
        </member>
        <member name="M:Interop.Mso.IMsoComponentManager.FSetTrackingComponent(System.UIntPtr,Interop.BOOL)">
             <summary>
              Called to inform component manager that component identified by <paramref name="dwComponentID"/>
              (cookie returned from <see cref="M:Interop.Mso.IMsoComponentManager.FRegisterComponent(Interop.Mso.IMsoComponent,Interop.Mso.MSOCRINFO*,System.UIntPtr*)"/>) wishes to perform a tracking operation
              (such as mouse tracking).
             </summary>
             <remarks>
              During the tracking operation the component manager routes messages to the tracking component
              (via <see cref="M:Interop.Mso.IMsoComponent.FPreTranslateMessage(Interop.User32.MSG*)"/>) rather than to the active component.
              When the tracking operation ends, the component manager should resume routing messages to the active
              component.
            
              Note: component manager should perform no idle time processing during a tracking operation other
              than give the tracking component idle time via <see cref="M:Interop.Mso.IMsoComponent.FDoIdle(Interop.Mso.msoidlef)"/>.
            
              Note: there can only be one tracking component at a time.
             </remarks>
             <param name="fTrack">
              <see cref="F:Interop.BOOL.TRUE"/> to begin tracking operation. <see cref="F:Interop.BOOL.FALSE"/>
              to end the operation.
             </param>
             <returns><see cref="F:Interop.BOOL.TRUE"/> if successful.</returns>
        </member>
        <member name="M:Interop.Mso.IMsoComponentManager.OnComponentEnterState(System.UIntPtr,Interop.Mso.msocstate,Interop.Mso.msoccontext,System.UInt32,System.Void**,System.UInt32)">
             <summary>
              Notify component manager that component identified by <paramref name="dwComponentID"/>
              (cookie returned from <see cref="M:Interop.Mso.IMsoComponentManager.FRegisterComponent(Interop.Mso.IMsoComponent,Interop.Mso.MSOCRINFO*,System.UIntPtr*)"/>) is entering the state identified
              by <paramref name="uStateID"/>. (For convenience when dealing with sub CompMgrs, the host
              can call this method passing 0 for <paramref name="dwComponentID"/>.
             </summary>
             <remarks>
              Component manager should notify all other interested components within the state context
              indicated by <paramref name="uContext"/>, excluding those within the state context of a
              component manager in <paramref name="rgpicmExclude"/>, via
              <see cref="M:Interop.Mso.IMsoComponent.OnEnterState(Interop.Mso.msocstate,Interop.BOOL)"/> (see "Comments on State Contexts" in
              <see cref="T:Interop.Mso.IMsoComponentManager"/> remarks).
            
              Component Manager should also take appropriate action depending on the value of
              <paramref name="uStateID"/>.
            
              Note: Calls to this method are symmetric with calls to <see cref="M:Interop.Mso.IMsoComponentManager.FOnComponentExitState(System.UIntPtr,Interop.Mso.msocstate,Interop.Mso.msoccontext,System.UInt32,System.Void**)" />
              That is, if n <see cref="M:Interop.Mso.IMsoComponentManager.OnComponentEnterState(System.UIntPtr,Interop.Mso.msocstate,Interop.Mso.msoccontext,System.UInt32,System.Void**,System.UInt32)"/> calls are made, the component is
              considered to be in the state until n <see cref="M:Interop.Mso.IMsoComponentManager.FOnComponentExitState(System.UIntPtr,Interop.Mso.msocstate,Interop.Mso.msoccontext,System.UInt32,System.Void**)" /> calls are
              made.  Before revoking its registration a component must make a sufficient number of
              <see cref="M:Interop.Mso.IMsoComponentManager.FOnComponentExitState(System.UIntPtr,Interop.Mso.msocstate,Interop.Mso.msoccontext,System.UInt32,System.Void**)" /> calls to offset any outstanding
              <see cref="M:Interop.Mso.IMsoComponentManager.OnComponentEnterState(System.UIntPtr,Interop.Mso.msocstate,Interop.Mso.msoccontext,System.UInt32,System.Void**,System.UInt32)"/> calls it has made.
            
              Note: inplace objects should not call this method with <paramref name="uStateID" />
              of <see cref="F:Interop.Mso.msocstate.Modal"/> when entering modal state. Such objects should call
              <see cref="M:Interop.Ole32.IOleInPlaceFrame.EnableModeless(Interop.BOOL)"/> instead.
             </remarks>
             <param name="dwReserved">Reserved for future use. Should be zero.</param>
             <param name="cpicmExclude">Count of items in <paramref name="rgpicmExclude"/>.</param>
             <param name="rgpicmExclude">
              Can be null. An array of component managers (can include root component manager and/or
              sub component managers). Components within the state context of a component manager
              appearing in this array should NOT be notified of the state change (note: if
              <paramref name="uContext"/> is <see cref="F:Interop.Mso.msoccontext.Mine"/>, the only component
              managers in <paramref name="rgpicmExclude"/> that are checked for exclusion are those that
              are sub component managers of this component manager, since all other component
              managers are outside of this component manager's state context anyway.)
             </param>
        </member>
        <member name="M:Interop.Mso.IMsoComponentManager.FOnComponentExitState(System.UIntPtr,Interop.Mso.msocstate,Interop.Mso.msoccontext,System.UInt32,System.Void**)">
             <summary>
              Notify component manager that component identified by <paramref name="dwComponentID"/>
              (cookie returned from <see cref="M:Interop.Mso.IMsoComponentManager.FRegisterComponent(Interop.Mso.IMsoComponent,Interop.Mso.MSOCRINFO*,System.UIntPtr*)"/>) is exiting the state identified by
              <paramref name="uStateID"/>. For convenience when dealing with sub component managers, the
              host can call this method passing 0 for <paramref name="dwComponentID"/>.
             </summary>
             <remarks>
              <paramref name="uContext"/>, <paramref name="cpicmExclude"/>, and <paramref name="rgpicmExclude"/>
              are as they are in <see cref="M:Interop.Mso.IMsoComponentManager.OnComponentEnterState(System.UIntPtr,Interop.Mso.msocstate,Interop.Mso.msoccontext,System.UInt32,System.Void**,System.UInt32)"/>.
            
              Component manager should notify all appropriate interested components (taking into account
              <paramref name="uContext"/>, <paramref name="cpicmExclude"/>, <paramref name="rgpicmExclude"/>)
              via <see cref="M:Interop.Mso.IMsoComponent.OnEnterState(Interop.Mso.msocstate,Interop.BOOL)"/> (see "Comments on State Contexts", above).
            
              Component manager should also take appropriate action depending on the value of <paramref name="uStateID"/>.
            
              Note: n calls to this method are symmetric with n calls to <see cref="M:Interop.Mso.IMsoComponentManager.OnComponentEnterState(System.UIntPtr,Interop.Mso.msocstate,Interop.Mso.msoccontext,System.UInt32,System.Void**,System.UInt32)"/>.
             </remarks>
             <returns>
              <see cref="F:Interop.BOOL.TRUE"/> if, at the end of this call, the state is still in effect at the root
              of this component manager's state context (because the host or some other component is still in the state),
              otherwise return <see cref="F:Interop.BOOL.FALSE"/> (ie. return what <see cref="M:Interop.Mso.IMsoComponentManager.FInState(Interop.Mso.msocstate,System.Void*)"/> would return).
            
              Callers can normally ignore the return value.
             </returns>
        </member>
        <member name="M:Interop.Mso.IMsoComponentManager.FInState(Interop.Mso.msocstate,System.Void*)">
            <summary>
             Return <see cref="F:Interop.BOOL.TRUE"/> if the state identified by <paramref name="uStateID"/>
             is in effect at the root of this component manager's state context, <see cref="F:Interop.BOOL.FALSE"/>
             otherwise (see "Comments on State Contexts" in <see cref="T:Interop.Mso.IMsoComponentManager"/> remarks).
            </summary>
            <param name="pvoid">Reserved for future use and should be <see langword="null" />.</param>
        </member>
        <member name="M:Interop.Mso.IMsoComponentManager.FContinueIdle">
            <summary>
             Called periodically by a component during <see cref="M:Interop.Mso.IMsoComponent.FDoIdle(Interop.Mso.msoidlef)"/>.
            </summary>
            <returns>
             <see cref="F:Interop.BOOL.TRUE"/> if component can continue its idle time processing,
             <see cref="F:Interop.BOOL.FALSE"/> if not (in which case component returns from FDoIdle.)
            </returns>
        </member>
        <member name="M:Interop.Mso.IMsoComponentManager.FPushMessageLoop(System.UIntPtr,Interop.Mso.msoloop,System.Void*)">
            <summary>
             Component identified by <paramref name="dwComponentID"/> (cookie returned from
             <see cref="M:Interop.Mso.IMsoComponentManager.FRegisterComponent(Interop.Mso.IMsoComponent,Interop.Mso.MSOCRINFO*,System.UIntPtr*)"/>) wishes to push a message loop for reason
             <paramref name="uReason"/>.
            </summary>
            <remarks>
             The component manager should push its message loop, calling
             <see cref="M:Interop.Mso.IMsoComponent.FContinueMessageLoop(Interop.Mso.msoloop,System.Void*,Interop.User32.MSG*)"/> during each loop iteration. When
             <see cref="M:Interop.Mso.IMsoComponent.FContinueMessageLoop(Interop.Mso.msoloop,System.Void*,Interop.User32.MSG*)"/> returns <see cref="F:Interop.BOOL.FALSE"/>,
             the component manager terminates the loop.
            </remarks>
            <param name="pvLoopData">Data private to the component.</param>
            <returns>
             <see cref="F:Interop.BOOL.TRUE"/> if component manager terminates loop because component told it
             to (by returning <see cref="F:Interop.BOOL.FALSE"/> from <see cref="M:Interop.Mso.IMsoComponent.FContinueMessageLoop(Interop.Mso.msoloop,System.Void*,Interop.User32.MSG*)"/>),
             <see cref="F:Interop.BOOL.FALSE"/> if it had to terminate the loop for some other reason.  In the
             latter case, component should perform any necessary action (such as cleanup).
            </returns>
        </member>
        <member name="M:Interop.Mso.IMsoComponentManager.FCreateSubComponentManager(System.IntPtr,System.IntPtr,System.Guid*,System.Void**)">
            <summary>
             Cause the component manager to create a "sub" component manager, which  will be one of its
             children in the hierarchical tree of component managers used to maintain state contexts
             (see "Comments on State Contexts" in <see cref="T:Interop.Mso.IMsoComponentManager"/> remarks).
            </summary>
            <param name="punkOuter">The controlling unknown. Can be null.</param>
            <param name="riid">Desired interface identifier (IID).</param>
            <param name="ppvObj">The created sub-component manager.</param>
            <param name="punkServProv">
             IUnknown object that supports IServiceProvider that the sub component manager should
             delegate <see cref="M:Interop.Mso.IMsoComponentManager.QueryService(System.Guid*,System.Guid*,System.Void**)" /> calls to. Can be null.
            </param>
            <returns><see cref="F:Interop.BOOL.TRUE"/> if successful.</returns>
        </member>
        <member name="M:Interop.Mso.IMsoComponentManager.FGetParentComponentManager(System.Void**)">
            <summary>
             Return in <paramref name="ppicm"/> an AddRef'ed ptr to this component manager's parent
             in the hierarchical tree of component managers used to maintain state contexts (see
             "Comments on State Contexts" in <see cref="T:Interop.Mso.IMsoComponentManager"/> remarks).
            </summary>
            <returns>
             <see cref="F:Interop.BOOL.TRUE"/> if the parent is returned, <see cref="F:Interop.BOOL.FALSE"/>
             if no parent exists or some error occurred.
            </returns>
        </member>
        <member name="M:Interop.Mso.IMsoComponentManager.FGetActiveComponent(Interop.Mso.msogac,System.Void**,Interop.Mso.MSOCRINFO*,System.UInt32)">
             <summary>
              Return in <paramref name="ppic"/> an AddRef'ed ptr to the current active
              or tracking component (as indicated by <paramref name="dwgac"/>, and its
              registration information in <paramref name="pcrinfo"/>.
            
              <paramref name="ppic"/> and/or <paramref name="pcrinfo"/> can be
              NULL if caller is not interested these values.  If <paramref name="pcrinfo"/>
              is not <see langword="null" /> caller should set <see cref="F:Interop.Mso.MSOCRINFO.cbSize"/>
              before calling this method.
             </summary>
             <param name="dwReserved">Reserved for future use and should be zero.</param>
             <returns>
              <see cref="F:Interop.BOOL.TRUE"/> if the component indicated by <paramref name="dwgac"/>
              exists, <see cref="F:Interop.BOOL.FALSE"/> if no such component exists or some error occurred.
             </returns>
        </member>
        <member name="T:Interop.Mso.msocadvf">
            <summary>
             MSO Component registration advise flags <see cref="T:Interop.Mso.msocstate" />
            </summary>
        </member>
        <member name="T:Interop.Mso.msoccontext">
             <summary>
              <see cref="M:Interop.Mso.IMsoComponentManager.FCreateSubComponentManager(System.IntPtr,System.IntPtr,System.Guid*,System.Void**)" /> allows one to create a hierarchical
              tree of component managers. This tree is used to maintain multiple contexts with regard to
              <see cref="T:Interop.Mso.msocstate"/> states. These contexts are referred to as 'state contexts'
            
              Each component manager in the tree defines a state context.  The components registered with a
              particular component manager or any of its descendents live within that component manager's
              state context.  Calls to <see cref="M:Interop.Mso.IMsoComponentManager.OnComponentEnterState(System.UIntPtr,Interop.Mso.msocstate,Interop.Mso.msoccontext,System.UInt32,System.Void**,System.UInt32)"/>
              and <see cref="M:Interop.Mso.IMsoComponentManager.FOnComponentExitState(System.UIntPtr,Interop.Mso.msocstate,Interop.Mso.msoccontext,System.UInt32,System.Void**)"/> can be used to affect all components,
              only components within the component manager's state context, or only those components that are
              outside of the component manager's state context. <see cref="M:Interop.Mso.IMsoComponentManager.FInState(Interop.Mso.msocstate,System.Void*)" />
              is used to query the state of the component manager's state context at its root.
             </summary>
        </member>
        <member name="T:Interop.Mso.msocrf">
            <summary>
             MSO Component registration flags
            </summary>
        </member>
        <member name="F:Interop.Mso.MSOCRINFO.cbSize">
            <summary>
             The size, in bytes, of the <see cref="T:Interop.Mso.MSOCRINFO" /> structure.
            </summary>
        </member>
        <member name="F:Interop.Mso.MSOCRINFO.uIdleTimeInterval">
            <summary>
             The interval time, in milliseconds, of when a periodic idle phase
             should occur. During the idle phase, the component needs to perform
             idle-time tasks. This member applies only if the msocrfNeedPeriodicIdleTime
             bit flag is registered in the <see cref="F:Interop.Mso.MSOCRINFO.grfcrf" /> member.
            </summary>
        </member>
        <member name="F:Interop.Mso.MSOCRINFO.grfcrf">
            <summary>
             Registration flags.
            </summary>
        </member>
        <member name="F:Interop.Mso.MSOCRINFO.grfcadvf">
            <summary>
             Registration advise flags.
            </summary>
        </member>
        <member name="T:Interop.Mso.msocstate">
             <summary>
              State IDs passed to <see cref="M:Interop.Mso.IMsoComponent.OnEnterState(Interop.Mso.msocstate,Interop.BOOL)" /> and
              <see cref="M:Interop.Mso.IMsoComponentManager.OnComponentEnterState(System.UIntPtr,Interop.Mso.msocstate,Interop.Mso.msoccontext,System.UInt32,System.Void**,System.UInt32)" />
            
              When the host or a component is notified through one of these methods that another
              entity(component or host) is entering or exiting a state identified by one of these
              state IDs, the host/component should take appropriate action.
             </summary>
        </member>
        <member name="F:Interop.Mso.msocstate.Modal">
            <summary>
             If app is entering modal state, host/component should disable
             its toplevel windows, and reenable them when app exits this
             state.  Also, when this state is entered or exited, host/component
             should notify approprate inplace objects via
             IOleInPlaceActiveObject::EnableModeless.
            </summary>
        </member>
        <member name="F:Interop.Mso.msocstate.RedrawOff">
            <summary>
             If app is entering redraw fff state, host/component should disable
             repainting of its windows, and reenable repainting when app exits
             this state.
            </summary>
        </member>
        <member name="F:Interop.Mso.msocstate.WarningsOff">
            <summary>
             If app is entering warnings off state, host/component should disable
             the presentation of any user warnings, and reenable this when
             app exits this state.
            </summary>
        </member>
        <member name="F:Interop.Mso.msocstate.Recording">
            <summary>
             Used to notify host/component when Recording is turned on or off.
            </summary>
        </member>
        <member name="T:Interop.Mso.msoloop">
            <summary>
             Reasons for pushing a message loop as passed to <see cref="M:Interop.Mso.IMsoComponentManager.FPushMessageLoop(System.UIntPtr,Interop.Mso.msoloop,System.Void*)" />.
             The host should remain in message loop until <see cref="M:Interop.Mso.IMsoComponent.FContinueMessageLoop(Interop.Mso.msoloop,System.Void*,Interop.User32.MSG*)" />
             returns <see cref="F:Interop.BOOL.FALSE" />
            </summary>
        </member>
        <member name="T:Interop.NtDll.RTL_OSVERSIONINFOEX">
            <summary>
             Version info structure for <see cref="M:Interop.NtDll.RtlGetVersion(Interop.NtDll.RTL_OSVERSIONINFOEX@)" />
            </summary>
            <remarks>
             Note that this structure is the exact same defintion as OSVERSIONINFOEX.
            </remarks>
        </member>
        <member name="M:Interop.Ole32.IEnumOLEVERB.Next(System.UInt32,Interop.Ole32.OLEVERB,System.UInt32*)">
            <remarks>
             This method really should take OLEVERB* (i.e. an array of OLEVERB structs).
             However, OLEVERB is defined as a class meaning that we can only support
             celt values of 1.
            </remarks>
        </member>
        <member name="P:Interop.Ole32.IPicture.Handle">
            <remarks>
             IPicture handles are sign extended on 64 bit devices. To preserve
             the sign, handles should be represented as ints, not uints.
            </remarks>
        </member>
        <member name="P:Interop.Ole32.IPicture.hPal">
            <remarks>
             HPALETTE handles are sign extended on 64 bit devices. To preserve
             the sign, handles should be represented as ints, not uints.
            </remarks>
        </member>
        <member name="P:Interop.Ole32.IPicture.Type">
            <remarks>
             This is actually <see cref="T:Interop.Ole32.PICTYPE"/>, but we can't describe it as such.
             We want <see cref="T:Interop.Ole32.PICTYPE"/> to be <see langword="uint"/> so that
             <see cref="T:Interop.Ole32.PICTDESC"/> is blittable.
            </remarks>
        </member>
        <member name="P:Interop.Ole32.IPictureDisp.Handle">
            <remarks>
             IPicture handles are sign extended on 64 bit devices. To preserve
             the sign, handles should be represented as ints, not uints.
            </remarks>
        </member>
        <member name="P:Interop.Ole32.IPictureDisp.hPal">
            <remarks>
             HPALETTE handles are sign extended on 64 bit devices. To preserve
             the sign, handles should be represented as ints, not uints.
            </remarks>
        </member>
        <member name="P:Interop.Ole32.IPictureDisp.Type">
            <remarks>
             This is actually <see cref="T:Interop.Ole32.PICTYPE"/>, but we can't describe it as such.
             We want <see cref="T:Interop.Ole32.PICTYPE"/> to be <see langword="uint"/> so that
             <see cref="T:Interop.Ole32.PICTDESC"/> is blittable.
            </remarks>
        </member>
        <member name="T:Interop.Ole32.IServiceProvider">
            <remarks>
             As the name conflicts with <see cref="T:System.IServiceProvider"/> this is sometimes
             called IOleServiceProvider, even though the name is actually IServiceProvider.
             <see href="https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/cc678966(v=vs.85)">QueryService method (Microsoft Docs)</see>
            </remarks>
        </member>
        <member name="T:Interop.Ole32.IStream">
            <summary>
             COM IStream interface. <see href="https://docs.microsoft.com/en-us/windows/desktop/api/objidl/nn-objidl-istream"/>
            </summary>
            <remarks>
             The definition in <see cref="N:System.Runtime.InteropServices.ComTypes"/> does not lend
             itself to efficiently accessing / implementing IStream.
            </remarks>
        </member>
        <member name="M:Interop.Ole32.OleCreatePictureIndirect(Interop.Ole32.PICTDESC@,System.Guid@,Interop.BOOL)">
            <param name="fOwn">
             <see cref="F:Interop.BOOL.TRUE"/> if the picture object is to destroy its picture when the object is destroyed.
             (The picture handle in the <paramref name="pictdesc"/>.)
            </param>
        </member>
        <member name="T:Interop.Ole32.PICTYPE">
            <summary>
             Picture type used with <see cref="T:Interop.Ole32.IPicture"/> and <see cref="T:Interop.Ole32.PICTDESC"/>.
             <see href="https://docs.microsoft.com/windows/win32/com/pictype-constants"/>
            </summary>
            <remarks>
             This enum is explicitly set as int to try and avoid sign-extension
             errors when converting between type sizes (as it's usage is different
             between IPicture and PICTDESC). We use the larger type here to allow
             the PICTDESC struct to directly use this and remain blittable.
            </remarks>
        </member>
        <member name="T:Interop.Ole32.QACONTROL">
            <remarks>
             Specifies control information for IQuickActivate::QuickActivate.
             See https://docs.microsoft.com/en-us/windows/win32/api/ocidl/ns-ocidl-qacontrol
            </remarks>
        </member>
        <member name="T:Interop.Ole32.STATFLAG">
            <summary>
             Stat flags for <see cref="M:Interop.Ole32.IStream.Stat(Interop.Ole32.STATSTG@,Interop.Ole32.STATFLAG)"/>.
            <see href="https://docs.microsoft.com/en-us/windows/desktop/api/wtypes/ne-wtypes-tagstatflag"/>
            </summary>
        </member>
        <member name="F:Interop.Ole32.STATFLAG.DEFAULT">
            <summary>
             Stat includes the name.
            </summary>
        </member>
        <member name="F:Interop.Ole32.STATFLAG.NONAME">
            <summary>
             Stat doesn't include the name.
            </summary>
        </member>
        <member name="T:Interop.Ole32.STATSTG">
            <summary>
             Statistics for <see cref="T:Interop.Ole32.IStream"/>.
            <see href="https://docs.microsoft.com/en-us/windows/desktop/api/objidl/ns-objidl-tagstatstg"/>
            </summary>
            <remarks>
             The definition in <see cref="N:System.Runtime.InteropServices.ComTypes"/> isn't blittable.
            </remarks>
        </member>
        <member name="F:Interop.Ole32.STATSTG.pwcsName">
            <summary>
             Pointer to the name.
            </summary>
        </member>
        <member name="F:Interop.Ole32.STATSTG.cbSize">
            <summary>
             Size of the stream in bytes.
            </summary>
        </member>
        <member name="F:Interop.Ole32.STATSTG.grfMode">
            <summary>
             The stream mode.
            </summary>
        </member>
        <member name="F:Interop.Ole32.STATSTG.grfLocksSupported">
            <summary>
             Supported locking modes.
            <see href="https://docs.microsoft.com/en-us/windows/desktop/api/objidl/ne-objidl-taglocktype"/>
            </summary>
            <remarks>
             '0' means does not support lock modes.
            </remarks>
        </member>
        <member name="F:Interop.Ole32.STATSTG.clsid">
            <remarks>
             Only for IStorage objects
            </remarks>
        </member>
        <member name="F:Interop.Ole32.STATSTG.grfStateBits">
            <remarks>
             Only valid for IStorage objects.
            </remarks>
        </member>
        <member name="M:Interop.Ole32.STATSTG.FreeName">
            <summary>
             Caller is responsible for freeing the name memory.
            </summary>
        </member>
        <member name="M:Interop.Ole32.STATSTG.AllocName(System.String)">
            <summary>
             Callee is repsonsible for allocating the name memory.
            </summary>
        </member>
        <member name="T:Interop.Ole32.STGM">
            <summary>
             Stream / storage modes.
            <see href="https://docs.microsoft.com/en-us/windows/desktop/Stg/stgm-constants"/>
            </summary>
        </member>
        <member name="F:Interop.Ole32.STGM.Default">
            <summary>
             Read only, and each change to a storage or stream element is written as it occurs.
             Fails if the given storage object already exists.
             [DIRECT] [READ] [FAILIFTHERE] [SHARE_DENY_WRITE]
            </summary>
        </member>
        <member name="T:Interop.Ole32.STGTY">
            <summary>
             Type of the storage element. Used with <see cref="T:Interop.Ole32.STATSTG"/>.
            <see href="https://docs.microsoft.com/en-us/windows/desktop/api/objidl/ne-objidl-tagstgty"/>
            </summary>
        </member>
        <member name="M:Interop.Oleaut32.ITypeInfo.GetTypeComp(System.IntPtr*)">
            <remarks>
            This method is unused so we do not define the interface ITypeComp
            and its dependencies to avoid maintenance costs and code size.
            </remarks>
        </member>
        <member name="M:Interop.Oleaut32.ITypeInfo.GetContainingTypeLib(System.IntPtr*,System.UInt32*)">
            <remarks>
            This method is unused so we do not define the interface ITypeLib
            and its dependencies to avoid maintenance costs and code size.
            </remarks>
        </member>
        <member name="T:Interop.Oleaut32.VARIANT">
            <remarks>
             This implementation supports both VARIANT and VARIANTARG semantics.
             See https://devblogs.microsoft.com/oldnewthing/20171221-00/?p=97625
            </remarks>
        </member>
        <member name="T:Interop.Shell32.IFileDialogEvents">
            <remarks>
             Some of these callbacks are cancelable - returning S_FALSE means that the dialog should
             not proceed (e.g. with closing, changing folder); to support this, we need to use the
             PreserveSig attribute to enable us to return the proper HRESULT
            </remarks>
        </member>
        <member name="F:Interop.UiaCore.ExpandCollapseState.Collapsed">
            <summary>
             No children are showing
            </summary>
        </member>
        <member name="F:Interop.UiaCore.ExpandCollapseState.Expanded">
            <summary>
             All children are showing
            </summary>
        </member>
        <member name="F:Interop.UiaCore.ExpandCollapseState.PartiallyExpanded">
            <summary>
             Not all children are showing
            </summary>
        </member>
        <member name="F:Interop.UiaCore.ExpandCollapseState.LeafNode">
            <summary>
             Does not expand or collapse
            </summary>
        </member>
        <member name="M:Interop.UiaCore.IAccessibleEx.GetObjectForChild(System.Int32)">
            <summary>
             Returns the IAccessibleEx for specified child. Returns
             S_OK/NULL if this implementation does not use child ids,
             or does not have an IAccessibleEx for the specified child,
             or already represents a child element.
             idChild must be normalized; ie. client must have previously
             used get_accChild to check whether it actually has its own
             IAccessible. Only idChild values that do not have a corresponding
             IAccessible can be used here.
            </summary>
        </member>
        <member name="M:Interop.UiaCore.IAccessibleEx.GetIAccessiblePair(System.Object@,System.Int32*)">
             <summary>
              Returns an IAccessible and idChild pair for this IAccessibleEx.
              Implementation must return fully normalized idChild values: ie.
              it is not required to call get_accChild on the resulting pair.
            
              For IAccessible implementations that do not use child ids, this
              just returns the corresponding IAccessible and CHILDID_SELF.
             </summary>
        </member>
        <member name="M:Interop.UiaCore.IAccessibleEx.ConvertReturnedElement(Interop.UiaCore.IRawElementProviderSimple,Interop.UiaCore.IAccessibleEx@)">
             <summary>
              Some wrapper-based implementations (notably UIABridge) can't reasonably wrap all
              IRawElementProviderSimple elements returned as property values or patterns, so
              these elements won't QI to IAccessibleEx. Where this is the case, the original
              IAccessibleEx that the property was retreived from must implement this method
              so that the client can get an IAccessibleEx.
            
              Usage for a client is as follows:
              When an IRawElementProviderSimple is obtained as a property value,
              - first try to QI to IAccessibleEx
              - if that fails, call this method on the source IAccessibleEx
             </summary>
        </member>
        <member name="M:Interop.UiaCore.IExpandCollapseProvider.Expand">
            <summary>
             Blocking method that returns after the element has been expanded.
            </summary>
        </member>
        <member name="M:Interop.UiaCore.IExpandCollapseProvider.Collapse">
            <summary>
             Blocking method that returns after the element has been collapsed.
            </summary>
        </member>
        <member name="P:Interop.UiaCore.IExpandCollapseProvider.ExpandCollapseState">
            <summary>
             Indicates an element's current Collapsed or Expanded state
            </summary>
        </member>
        <member name="T:Interop.UiaCore.IInvokeProvider">
             <summary>
              Implemented by objects that have a single, unambiguous, action associated with them.
              These objects are usually stateless, and invoking them does not change their own state,
              but causes something to happen in the larger context of the app the control is in.
            
              Examples of UI that implments this includes:
              Push buttons
              Hyperlinks
              Menu items
             </summary>
        </member>
        <member name="M:Interop.UiaCore.IInvokeProvider.Invoke">
            <summary>
             Request that the control initiate its action.
             Should return immediately without blocking.
             There is no way to determine what happened, when it happend, or whether
             anything happened at all.
            </summary>
        </member>
        <member name="T:Interop.UiaCore.IRawElementProviderFragment">
             <summary>
              Implemented by providers to expose elements that are part of
              a structure more than one level deep. For simple one-level
              structures which have no children, IRawElementProviderSimple
              can be used instead.
            
              The root node of the fragment must support the IRawElementProviderFragmentRoot
              interface, which is derived from this, and has some additional methods.
             </summary>
        </member>
        <member name="M:Interop.UiaCore.IRawElementProviderFragment.Navigate(Interop.UiaCore.NavigateDirection)">
            <summary>
             Request to return the element in the specified direction
            </summary>
            <param name="direction">Indicates the direction in which to navigate</param>
            <returns>Returns the element in the specified direction</returns>
        </member>
        <member name="M:Interop.UiaCore.IRawElementProviderFragment.GetRuntimeId">
            <summary>
             Gets the runtime ID of an elemenent. This should be unique
             among elements on a desktop.
            </summary>
            <remarks>
             Proxy implementations should return null for the top-level proxy which
             correpsonds to the HWND; and should return an array which starts
             with AutomationInteropProvider.AppendRuntimeId, followed by values
             which are then unique within that proxy's HWNDs.
            </remarks>
        </member>
        <member name="P:Interop.UiaCore.IRawElementProviderFragment.BoundingRectangle">
            <summary>
             Return a bounding rectangle of this element
            </summary>
        </member>
        <member name="M:Interop.UiaCore.IRawElementProviderFragment.GetEmbeddedFragmentRoots">
             <summary>
              If this UI is capable of hosting other UI that also supports UIAutomation, and
              the subtree rooted at this element contains such hosted UI fragments, this should return
              an array of those fragments.
            
              If this UI does not host other UI, it may return null.
             </summary>
        </member>
        <member name="M:Interop.UiaCore.IRawElementProviderFragment.SetFocus">
            <summary>
             Request that focus is set to this item.
             The UIAutomation framework will ensure that the UI hosting this fragment is already
             focused before calling this method, so this method should only update its internal
             focus state; it should not attempt to give its own HWND the focus, for example.
            </summary>
        </member>
        <member name="P:Interop.UiaCore.IRawElementProviderFragment.FragmentRoot">
            <summary>
             Return the element that is the root node of this fragment of UI.
            </summary>
        </member>
        <member name="T:Interop.UiaCore.IRawElementProviderFragmentRoot">
            <summary>
             The root element in a fragment of UI must support this interface. Other
             elements in the same fragment need to support the IRawElementProviderFragment
             interface.
            </summary>
        </member>
        <member name="M:Interop.UiaCore.IRawElementProviderFragmentRoot.ElementProviderFromPoint(System.Double,System.Double)">
            <summary>
             Return the child element at the specified point, if one exists,
             otherwise return this element if the point is on this element,
             otherwise return null.
            </summary>
            <param name="x">x coordinate of point to check</param>
            <param name="y">y coordinate of point to check</param>
            <returns>Return the child element at the specified point, if one exists,
             otherwise return this element if the point is on this element,
             otherwise return null.
            </returns>
        </member>
        <member name="M:Interop.UiaCore.IRawElementProviderFragmentRoot.GetFocus">
            <summary>
             Return the element in this fragment which has the keyboard focus,
            </summary>
            <returns>Return the element in this fragment which has the keyboard focus,
             if any; otherwise return null.</returns>
        </member>
        <member name="T:Interop.UiaCore.IRawElementProviderHwndOverride">
            <summary>
             Implemented by providers which want to provide information about or want to
             reposition contained HWND-based elements.
            </summary>
        </member>
        <member name="M:Interop.UiaCore.IRawElementProviderHwndOverride.GetOverrideProviderForHwnd(System.IntPtr)">
            <summary>
             Request a provider for the specified component. The returned provider can supply additional
             properties or override properties of the specified component.
            </summary>
            <param name="hwnd">The window handle of the component.</param>
            <returns>Return the provider for the specified component, or null if the component is not being overridden.</returns>
        </member>
        <member name="P:Interop.UiaCore.IRawElementProviderSimple.ProviderOptions">
             <summary>
              Indicates the type of provider this is, for example, whether it is a client-side
              or server-side provider.
             </summary>
             <remarks>
              Providers must specify at least either one of ProviderOptions.ClientSideProvider
              or ProviderOptions.ServerSideProvider.
            
              UIAutomation treats different types of providers
              differently - for example, events from server-side provider are broadcast to all listening
              clients, whereas events from client-side providers remain in that client.
             </remarks>
        </member>
        <member name="M:Interop.UiaCore.IRawElementProviderSimple.GetPatternProvider(Interop.UiaCore.UIA)">
            <summary>
             Get a pattern interface from this object
            </summary>
            <param name="patternId">Identifier indicating the interface to return</param>
            <returns>Returns the interface as an object, if supported; otherwise returns null/</returns>
        </member>
        <member name="M:Interop.UiaCore.IRawElementProviderSimple.GetPropertyValue(Interop.UiaCore.UIA)">
            <summary>
             Request value of specified property from an element.
            </summary>
            <param name="propertyId">Identifier indicating the property to return</param>
            <returns>Returns a ValInfo indicating whether the element supports this property, or has no value for it.</returns>
        </member>
        <member name="P:Interop.UiaCore.IRawElementProviderSimple.HostRawElementProvider">
             <summary>
              Returns a base provider for this element.
            
              Typically only used by elements that correspond directly to a Win32 Window Handle,
              in which case the implementation returns AutomationInteropProvider.BaseElementFromHandle( hwnd ).
             </summary>
        </member>
        <member name="T:Interop.UiaCore.IScrollItemProvider">
            <summary>
             Implemented by objects in a known Scrollable context, such as ListItems, ListViewItems, TreeViewItems, and Tabs.
             This allows them to be scrolled into view using known API's based on the control in question.
            </summary>
        </member>
        <member name="M:Interop.UiaCore.IScrollItemProvider.ScrollIntoView">
            <summary>
             Scrolls the windows containing this automation element to make this element visible.
             InvalidOperationException should be thrown if item becomes unable to be scrolled. Makes
             no guarantees about where the item will be in the scrolled window.
            </summary>
        </member>
        <member name="T:Interop.UiaCore.ISelectionItemProvider">
            <summary>
             Define a Selectable Item (only supported on logical elements that are a
             child of an Element that supports SelectionPattern and is itself selectable).
             This allows for manipulation of Selection from the element itself.
            </summary>
        </member>
        <member name="M:Interop.UiaCore.ISelectionItemProvider.Select">
            <summary>
             Sets the current element as the selection
             This clears the selection from other elements in the container.
            </summary>
        </member>
        <member name="M:Interop.UiaCore.ISelectionItemProvider.AddToSelection">
            <summary>
             Adds current element to selection.
            </summary>
        </member>
        <member name="M:Interop.UiaCore.ISelectionItemProvider.RemoveFromSelection">
            <summary>
             Removes current element from selection.
            </summary>
        </member>
        <member name="P:Interop.UiaCore.ISelectionItemProvider.IsSelected">
            <summary>
             Check whether an element is selected.
            </summary>
            <returns>Returns true if the element is selected.</returns>
        </member>
        <member name="P:Interop.UiaCore.ISelectionItemProvider.SelectionContainer">
            <summary>
             The logical element that supports the SelectionPattern for this Item.
            </summary>
            <returns>Returns a IRawElementProviderSimple.</returns>
        </member>
        <member name="T:Interop.UiaCore.ISelectionProvider">
            <summary>
             The interface representing containers that manage selection.
            </summary>
            <remarks>
             Client code uses this public interface; server implementers implent the
             ISelectionProvider public interface instead.
            </remarks>
        </member>
        <member name="M:Interop.UiaCore.ISelectionProvider.GetSelection">
            <summary>
             Get the currently selected elements
            </summary>
            <returns>An AutomationElement array containing the currently selected elements</returns>
        </member>
        <member name="P:Interop.UiaCore.ISelectionProvider.CanSelectMultiple">
            <summary>
             Indicates whether the control allows more than one element to be selected
            </summary>
            <returns>Boolean indicating whether the control allows more than one element to be selected</returns>
            <remarks>If this is false, then the control is a single-select ccntrol</remarks>
        </member>
        <member name="P:Interop.UiaCore.ISelectionProvider.IsSelectionRequired">
            <summary>
             Indicates whether the control requires at least one element to be selected
            </summary>
            <returns>Boolean indicating whether the control requires at least one element to be selected</returns>
            <remarks>If this is false, then the control allows all elements to be unselected</remarks>
        </member>
        <member name="P:Interop.UiaCore.IToggleProvider.ToggleState">
            <summary>
             Indicates an element's current on or off state
            </summary>
        </member>
        <member name="M:Interop.UiaCore.IValueProvider.SetValue(System.String)">
            <summary>
             Request to set the value that this UI element is representing
            </summary>
            <param name="value">Value to set the UI to</param>
        </member>
        <member name="P:Interop.UiaCore.IValueProvider.Value">
            <summary>Value of a value control, as a a string.</summary>
        </member>
        <member name="P:Interop.UiaCore.IValueProvider.IsReadOnly">
             <summary>Indicates that the value can only be read, not modified.
            returns True if the control is read-only</summary>
        </member>
        <member name="T:Interop.UiaCore.NavigateDirection">
            <summary>
             Directions for navigation the UIAutomation tree
            </summary>
        </member>
        <member name="F:Interop.UiaCore.NavigateDirection.Parent">
            <summary>
             Navigate to parent
            </summary>
        </member>
        <member name="F:Interop.UiaCore.NavigateDirection.NextSibling">
            <summary>
             Navigate to next sibling
            </summary>
        </member>
        <member name="F:Interop.UiaCore.NavigateDirection.PreviousSibling">
            <summary>
             Navigate to previous sibling
            </summary>
        </member>
        <member name="F:Interop.UiaCore.NavigateDirection.FirstChild">
            <summary>
             Navigate to first child
            </summary>
        </member>
        <member name="F:Interop.UiaCore.NavigateDirection.LastChild">
            <summary>
             Navigate to last child
            </summary>
        </member>
        <member name="F:Interop.UiaCore.ProviderOptions.ClientSideProvider">
            <summary>
            Indicates that this is a client-side provider
            </summary>
        </member>
        <member name="F:Interop.UiaCore.ProviderOptions.ServerSideProvider">
            <summary>
            Indicates that this is a server-side provider
            </summary>
        </member>
        <member name="F:Interop.UiaCore.ProviderOptions.NonClientAreaProvider">
            <summary>
            Indicates that this is a non-client-area provider
            </summary>
        </member>
        <member name="F:Interop.UiaCore.ProviderOptions.OverrideProvider">
            <summary>
            Indicates that this is an override provider
            </summary>
        </member>
        <member name="F:Interop.UiaCore.ProviderOptions.ProviderOwnsSetFocus">
            <summary>
            Indicates that this provider handles its own focus, and does not want
             UIA to set focus to the nearest HWND on its behalf when AutomationElement.SetFocus
             is used. This option is typically used by providers for HWNDs that appear to take
             focus without actually receiving actual Win32 focus, such as menus and dropdowns
            </summary>
        </member>
        <member name="F:Interop.UiaCore.ProviderOptions.UseComThreading">
            <summary>
             Indicates that this provider expects to be called according to COM threading rules:
             if the provider is in a Single-Threaded Apartment, it will be called only on the apartment
             thread. Only Server-side providers can use this option.
            </summary>
        </member>
        <member name="T:Interop.UiaCore.StructureChangeType">
            <summary>
             Logical structure change flags
            </summary>
        </member>
        <member name="F:Interop.UiaCore.StructureChangeType.ChildAdded">
            <summary>
             Logical child added
            </summary>
        </member>
        <member name="F:Interop.UiaCore.StructureChangeType.ChildRemoved">
            <summary>
             Logical child removed
            </summary>
        </member>
        <member name="F:Interop.UiaCore.StructureChangeType.ChildrenInvalidated">
            <summary>
             Logical children invalidated
            </summary>
        </member>
        <member name="F:Interop.UiaCore.StructureChangeType.ChildrenBulkAdded">
            <summary>
             Logical children were bulk added
            </summary>
        </member>
        <member name="F:Interop.UiaCore.StructureChangeType.ChildrenBulkRemoved">
            <summary>
             Logical children were bulk removed
            </summary>
        </member>
        <member name="F:Interop.UiaCore.StructureChangeType.ChildrenReordered">
            <summary>
             The order of the children below their parent has changed
            </summary>
        </member>
        <member name="M:Interop.User32.AreDpiAwarenessContextsEqual(System.IntPtr,System.IntPtr)">
            <summary>
             Tries to compare two DPIawareness context values. Return true if they were equal.
             Return false when they are not equal or underlying OS does not support this API.
            </summary>
            <returns>true/false</returns>
        </member>
        <member name="T:Interop.User32.BeginPaintScope">
            <summary>
             Helper to scope lifetime of an HDC retrieved via <see cref="M:Interop.User32.BeginPaint(System.IntPtr,Interop.User32.PAINTSTRUCT@)"/>
            </summary>
            <remarks>
             Use in a <see langword="using" /> statement. If you must pass this around, always pass
             by <see langword="ref" /> to avoid duplicating the handle and risking a double EndPaint.
            </remarks>
        </member>
        <member name="T:Interop.User32.CS">
            <summary>
             Class styles for <see cref="T:Interop.User32.WNDCLASS"/>
            </summary>
        </member>
        <member name="T:Interop.User32.DT">
            <summary>
             Text format flags for <see cref="M:Interop.User32.DrawTextExW(Interop.Gdi32.HDC,System.ReadOnlySpan{System.Char},Interop.RECT@,Interop.User32.DT,Interop.User32.DRAWTEXTPARAMS@)"/>
             and <see cref="M:Interop.User32.DrawTextW(Interop.Gdi32.HDC,System.String,System.Int32,Interop.RECT@,Interop.User32.DT)"/>
            </summary>
        </member>
        <member name="T:Interop.User32.GetDcScope">
            <summary>
             Helper to scope lifetime of an <see cref="T:Interop.Gdi32.HDC"/> retrieved via <see cref="M:Interop.User32.GetDC(System.IntPtr)"/> and
             <see cref="M:Interop.User32.GetDCEx(System.IntPtr,System.IntPtr,Interop.User32.DCX)"/>. Releases the <see cref="T:Interop.Gdi32.HDC"/> (if any) when disposed.
            </summary>
            <remarks>
             Use in a <see langword="using" /> statement. If you must pass this around, always pass by <see langword="ref" />
             to avoid duplicating the handle and risking a double release.
            </remarks>
        </member>
        <member name="M:Interop.User32.GetDcScope.#ctor(System.IntPtr,System.IntPtr,Interop.User32.DCX)">
             <summary>
              Creates a <see cref="T:Interop.Gdi32.HDC"/> using <see cref="M:Interop.User32.GetDCEx(System.IntPtr,System.IntPtr,Interop.User32.DCX)"/>.
             </summary>
             <remarks>
              GetWindowDC calls GetDCEx(hwnd, null, DCX_WINDOW | DCX_USESTYLE).
            
              GetDC calls GetDCEx(hwnd, null, DCX_USESTYLE) when given a handle. (When given null it has additional
              logic, and can't be replaced directly by GetDCEx.
             </remarks>
        </member>
        <member name="P:Interop.User32.GetDcScope.ScreenDC">
            <summary>
             Creates a DC scope for the primary monitor (not the entire desktop).
            </summary>
            <remarks>
              <see cref="M:Interop.Gdi32.CreateDC(System.String,System.String,System.String,System.IntPtr)" /> is the API to get the DC for the
              entire desktop.
            </remarks>
        </member>
        <member name="M:Interop.User32.GetMessageA(Interop.User32.MSG@,System.IntPtr,System.UInt32,System.UInt32)">
            <summary>
             Code page specific GetMessage. Use <see cref="M:Interop.User32.GetMessageW(Interop.User32.MSG@,System.IntPtr,System.UInt32,System.UInt32)"/> for Unicode.
            </summary>
        </member>
        <member name="M:Interop.User32.GetCurrentSystemMetrics(Interop.User32.SystemMetric,System.UInt32)">
            <summary>
             Tries to get system metrics for the dpi. dpi is ignored if "GetSystemMetricsForDpi" is not available on the OS that this application is running.
            </summary>
            <param name="nIndex">index</param>
            <param name="dpi">dpi requested</param>
            <returns>returns system metrics for dpi</returns>
        </member>
        <member name="M:Interop.User32.GetThreadDpiAwarenessContext">
            <summary>
             Tries to get thread dpi awareness context
            </summary>
            <returns>Returns thread dpi awareness context if API is available in this version of OS. otherwise, return IntPtr.Zero.</returns>
        </member>
        <member name="T:Interop.User32.GWL">
            <summary>
             Window long values for <see cref="M:Interop.User32.SetWindowLong(System.IntPtr,Interop.User32.GWL,System.IntPtr)"/> and
             <see cref="M:Interop.User32.GetWindowLong(System.IntPtr,Interop.User32.GWL)"/>.
            </summary>
        </member>
        <member name="T:Interop.User32.NMHDR">
            <remarks>
            NMHDR is defined in winuser.h and richedit.h. idFrom is a pointer in winuser.h but is an int
            in richedit.h. The definition in richedit.h is inactive and we use the definition in winuser.h.
            </remarks>
        </member>
        <member name="T:Interop.User32.RDW">
            <summary>
             <see cref="M:Interop.User32.RedrawWindow(System.IntPtr,Interop.RECT*,System.IntPtr,Interop.User32.RDW)"/> flags.
            </summary>
        </member>
        <member name="T:Interop.User32.SBH">
            <summary>
             Scroll bar values (SB_) that indicates the user's scrolling request in a horizontal scrollbar.
             Used by WM_HSCROLL message.
            </summary>
        </member>
        <member name="T:Interop.User32.SBV">
            <summary>
             Scroll bar values (SB_) that indicates the user's scrolling request in a vertical scrollbar.
             Used by WM_VSCROLL message.
            </summary>
        </member>
        <member name="M:Interop.User32.SetThreadDpiAwarenessContext(System.IntPtr)">
            <summary>
             Tries to set thread dpi awareness context
            </summary>
            <returns>Returns old thread dpi awareness context if API is available in this version of OS. otherwise, return IntPtr.Zero.</returns>
        </member>
        <member name="T:Interop.User32.SW">
            <summary>
             Show window flags for <see cref="M:Interop.User32.ShowWindow(System.IntPtr,Interop.User32.SW)"/> and
             <see cref="M:Interop.Shell32.ShellExecuteW(System.IntPtr,System.String,System.String,System.String,System.String,Interop.User32.SW)"/>
            </summary>
        </member>
        <member name="M:Interop.User32.TrySystemParametersInfoForDpi(Interop.User32.NONCLIENTMETRICSW@,System.UInt32)">
            <summary>
             Tries to get system parameter info for the dpi. dpi is ignored if "SystemParametersInfoForDpi()" API is not available on the OS that this application is running.
            </summary>
        </member>
        <member name="T:Interop.User32.WPF">
            <summary>
             Window placement flags for <see cref="T:Interop.User32.WINDOWPLACEMENT"/>.
            </summary>
        </member>
        <member name="T:Interop.User32.WS">
            <summary>
             Window styles
            </summary>
        </member>
        <member name="T:Interop.User32.WS_EX">
            <summary>
             Extended Window Styles
            </summary>
        </member>
        <member name="T:Interop.UxTheme.OpenThemeDataScope">
            <summary>
             Helper to scope the lifetime of a an HTHEME.
            </summary>
            <remarks>
             Use in a <see langword="using" /> statement. If you must pass this around, always pass by
             <see langword="ref" /> to avoid duplicating the handle and risking a double close.
            </remarks>
        </member>
        <member name="M:Interop.UxTheme.OpenThemeDataScope.#ctor(System.IntPtr,System.String)">
            <summary>
             Opens the requested theme data using <see cref="M:Interop.UxTheme.OpenThemeData(System.IntPtr,System.String)"/>.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.TRANSPARENT">
            <summary>
            Image has transparent areas (see TransparentColor).
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.AUTOSIZE">
            <summary>
            If TRUE, nonclient caption width varies with text extent.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.BORDERONLY">
            <summary>
            Only draw the border area of the image.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.COMPOSITED">
            <summary>
            Control will handle the composite drawing.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.BGFILL">
            <summary>
            If TRUE, TRUESIZE images should be drawn on bg fill
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.GLYPHTRANSPARENT">
            <summary>
            Glyph has transparent areas (see GlyphTransparentColor).
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.GLYPHONLY">
            <summary>
            Only draw glyph (not background).
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.ALWAYSSHOWSIZINGBAR">
            <summary>
            Default=TRUE means image gets mirrored in RTL (Mirror) windows.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.MIRRORIMAGE">
            <summary>
            If TRUE, height &amp; width must be uniformly sized.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.UNIFORMSIZING">
            <summary>
            For TRUESIZE and Border sizing; if TRUE, factor must be integer.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.INTEGRALSIZING">
            <summary>
            If TRUE, will scale up src image when needed.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.SOURCEGROW">
            <summary>
            If TRUE, will scale down src image when needed.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.IMAGECOUNT">
            <summary>
            The number of state images in an imagefile.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.ALPHALEVEL">
            <summary>
            (0-255) alpha value for an icon (DrawThemeIcon part).
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.BORDERSIZE">
            <summary>
            The size of the border line for bgtype=BorderFill.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.ROUNDCORNERWIDTH">
            <summary>
            (0-100) % of roundness for rounded rects.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.ROUNDCORNERHEIGHT">
            <summary>
            (0-100) % of roundness for rounded rects.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.GRADIENTRATIO1">
            <summary>
            (0-255) - amt of gradient color 1 to use (all must total=255).
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.GRADIENTRATIO2">
            <summary>
            (0-255) - amt of gradient color 2 to use (all must total=255).
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.GRADIENTRATIO3">
            <summary>
            (0-255) - amt of gradient color 3 to use (all must total=255).
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.GRADIENTRATIO4">
            <summary>
            (0-255) - amt of gradient color 4 to use (all must total=255).
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.GRADIENTRATIO5">
            <summary>
            (0-255) - amt of gradient color 5 to use (all must total=255).
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.PROGRESSCHUNKSIZE">
            <summary>
            Size of progress control chunks.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.PROGRESSSPACESIZE">
            <summary>
            Size of progress control spaces.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.SATURATION">
            <summary>
            (0-255) amt of saturation for DrawThemeIcon() part.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.TEXTBORDERSIZE">
            <summary>
            Size of border around text chars.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.ALPHATHRESHOLD">
            <summary>
            (0-255) the min. alpha value of a pixel that is solid.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.WIDTH">
            <summary>
            Custom window prop: size of part (min. window).
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.HEIGHT">
            <summary>
            Custom window prop: size of part (min. window)
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.GLYPHINDEX">
            <summary>
            For font-based glyphs, the char index into the font.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.TRUESIZESTRETCHMARK">
            <summary>
            Stretch TrueSize image when target exceeds source by this percent.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.MINDPI1">
            <summary>
            Min DPI ImageFile1 was designed for.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.MINDPI2">
            <summary>
            Min DPI ImageFile2 was designed for.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.MINDPI3">
            <summary>
            Min DPI ImageFile3 was designed for.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.MINDPI4">
            <summary>
            Min DPI ImageFile4 was designed for.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.MINDPI5">
            <summary>
            Min DPI ImageFile5 was designed for.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.GLYPHFONT">
            <summary>
            The font that the glyph is drawn with.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.IMAGEFILE">
            <summary>
            The filename of the image (or basename, for mult. images).
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.IMAGEFILE1">
            <summary>
            Multiresolution image file.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.IMAGEFILE2">
            <summary>
            Multiresolution image file.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.IMAGEFILE3">
            <summary>
            Multiresolution image file.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.IMAGEFILE4">
            <summary>
            Multiresolution image file.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.IMAGEFILE5">
            <summary>
            Multiresolution image file.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.STOCKIMAGEFILE">
            <summary>
            The filename for the glyph image
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.GLYPHIMAGEFILE">
            <summary>
            The filename for the glyph image
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.OFFSET">
            <summary>
            For window part layout.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.TEXTSHADOWOFFSET">
            <summary>
             Where char shadows are drawn, relative to orig. chars.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.MINSIZE">
            <summary>
            Min dest rect than ImageFile was designed for.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.MINSIZE1">
            <summary>
            Min dest rect than ImageFile1 was designed for.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.MINSIZE2">
            <summary>
            Min dest rect than ImageFile2 was designed for.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.MINSIZE3">
            <summary>
            Min dest rect than ImageFile3 was designed for.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.MINSIZE4">
            <summary>
            Min dest rect than ImageFile4 was designed for.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.MINSIZE5">
            <summary>
            Min dest rect than ImageFile5 was designed for.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.SIZINGMARGINS">
            <summary>
            margins used for 9-grid sizing.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.CONTENTMARGINS">
            <summary>
            margins that define where content can be placed.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.CAPTIONMARGINS">
            <summary>
            margins that define where caption text can be place
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.BORDERCOLOR">
            <summary>
            Color of borders for BorderFill.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.FILLCOLOR">
            <summary>
            Color of bg fill.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.TEXTCOLOR">
            <summary>
            Color text is drawn in.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.EDGELIGHTCOLOR">
            <summary>
            Edge light color.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.EDGEHIGHLIGHTCOLOR">
            <summary>
            Edge highlight color.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.EDGESHADOWCOLOR">
            <summary>
            Edge shadow color.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.EDGEDKSHADOWCOLOR">
            <summary>
            Edge dark shadow color.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.EDGEFILLCOLOR">
            <summary>
            Edge file color.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.TRANSPARENTCOLOR">
            <summary>
            Color of pixels that are treated as transparent (not drawn)
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.GRADIENTCOLOR1">
            <summary>
            First color in gradient.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.GRADIENTCOLOR2">
            <summary>
            Second color in gradient.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.GRADIENTCOLOR3">
            <summary>
            Third color in gradient.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.GRADIENTCOLOR4">
            <summary>
            Forth color in gradient.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.GRADIENTCOLOR5">
            <summary>
            Fifth color in gradient.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.SHADOWCOLOR">
            <summary>
            Color of text shadow.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.GLOWCOLOR">
            <summary>
            Color of glow produced by DrawThemeIcon.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.TEXTBORDERCOLOR">
            <summary>
            Color of text border.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.TEXTSHADOWCOLOR">
            <summary>
            Color of text shadow.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.GLYPHTEXTCOLOR">
            <summary>
            Color that font-based glyph is drawn with.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.GLYPHTRANSPARENTCOLOR">
            <summary>
            Color of transparent pixels in GlyphImageFile.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.FILLCOLORHINT">
            <summary>
            Hint about fill color used (for custom controls).
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.BORDERCOLORHINT">
            <summary>
            Hint about border color used (for custom controls).
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.ACCENTCOLORHINT">
            <summary>
            Hint about accent color used (for custom controls).
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.BGTYPE">
            <summary>
            Basic drawing type for each part.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.BORDERTYPE">
            <summary>
            Type of border for BorderFill parts.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.FILLTYPE">
            <summary>
            Fill shape for BorderFill parts.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.SIZINGTYPE">
            <summary>
            How to size ImageFile parts.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.HALIGN">
            <summary>
            Horizontal alignment for TRUESIZE parts &amp; glyphs.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.CONTENTALIGNMENT">
            <summary>
            Custom window prop: how text is aligned in caption.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.VALIGN">
            <summary>
            Horizontal alignment for TRUESIZE parts &amp; glyphs.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.OFFSETTYPE">
            <summary>
            How window part should be placed.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.ICONEFFECT">
            <summary>
            Type of effect to use with DrawThemeIcon.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.TEXTSHADOWTYPE">
            <summary>
            Type of shadow to draw with text.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.IMAGELAYOUT">
            <summary>
            How multiple images are arranged (horz. or vert.).
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.GLYPHTYPE">
            <summary>
            Controls type of glyph in imagefile objects.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.IMAGESELECTTYPE">
            <summary>
            Controls when to select from IMAGEFILE1...IMAGEFILE5.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.GLYPHFONTSIZINGTYPE">
            <summary>
            Controls when to select a bigger/small glyph font size.
            </summary>
        </member>
        <member name="F:Interop.UxTheme.TMT.TRUESIZESCALINGTYPE">
            <summary>
            Controls how TrueSize image is scaled
            </summary>
        </member>
        <member name="M:Interop.VSSDK.IVsPerPropertyBrowsing.HideProperty(Interop.Ole32.DispatchID,Interop.BOOL*)">
            <summary>
             Hides the property at the given dispid from the properties window
             implmentors should can return E_NOTIMPL to show all properties that
             are otherwise browsable.
            </summary>
        </member>
        <member name="M:Interop.VSSDK.IVsPerPropertyBrowsing.DisplayChildProperties(Interop.Ole32.DispatchID,Interop.BOOL*)">
            <summary>
             Will have the "+" expandable glyph next to them and can be expanded or collapsed by the user
             Returning a non-S_OK return code or false for pfDisplay will suppress this feature
            </summary>
        </member>
        <member name="M:Interop.VSSDK.IVsPerPropertyBrowsing.GetLocalizedPropertyInfo(Interop.Ole32.DispatchID,Interop.Kernel32.LCID,System.String[],System.String[])">
            <summary>
             Retrieves the localized name and description for a property.
             returning a non-S_OK return code will display the default values
            </summary>
        </member>
        <member name="M:Interop.VSSDK.IVsPerPropertyBrowsing.HasDefaultValue(Interop.Ole32.DispatchID,Interop.BOOL*)">
            <summary>
             Determines if the given (usually current) value for a property is the default.  If it is not default,
             the property will be shown as bold in the browser to indcate that it has been modified from the default.
            </summary>
        </member>
        <member name="M:Interop.VSSDK.IVsPerPropertyBrowsing.IsPropertyReadOnly(Interop.Ole32.DispatchID,Interop.BOOL*)">
            <summary>
             Determines if a property should be made read only.  This only applies to properties that are writeable,
            </summary>
        </member>
        <member name="M:Interop.VSSDK.IVsPerPropertyBrowsing.GetClassName(System.String@)">
            <summary>
             Returns the classname for this object. The class name is the non-bolded text
             that appears in the properties window selection combo.  If this method returns
             a non-S_OK return code, the default will be used. The default is the name
             string from a call to ITypeInfo::GetDocumentation(MEMID_NIL, ...);
            </summary>
        </member>
        <member name="M:Interop.VSSDK.IVsPerPropertyBrowsing.CanResetPropertyValue(Interop.Ole32.DispatchID,Interop.BOOL*)">
            <summary>
             Checks whether the given property can be reset to some default value.
             If return value is non-S_OK or *pfCanReset is
            </summary>
        </member>
        <member name="M:Interop.VSSDK.IVsPerPropertyBrowsing.ResetPropertyValue(Interop.Ole32.DispatchID)">
            <summary>
             If the return value is S_OK, the property's value will then be refreshed to the
             new default values.
            </summary>
        </member>
        <member name="T:IHandle">
             <summary>
              Used to abstract access to classes that contain a potentially owned handle.
             </summary>
             <remarks>
              The key benefit of this is that we can keep the owning class from being
              collected during interop calls. <see cref="T:System.Runtime.InteropServices.HandleRef"/> wraps arbitrary
              owners with target handles. Having this interface allows implicit use
              of the classes (such as System.Windows.Forms.Control) that
              meet this common pattern in interop and encourages correct alignment
              with the proper owner.
            
              Note that keeping objects alive is necessary ONLY when the object has
              a finalizer that will explicitly close the handle.
             </remarks>
        </member>
        <member name="T:System.Windows.Forms.ApplyGraphicsProperties">
            <summary>
             Enumeration defining the different Graphics properties to apply to a WindowsGraphics when creating it
             from a Graphics object.
            </summary>
        </member>
        <member name="F:System.Windows.Forms.ApplyGraphicsProperties.Clipping">
            <summary>
             Apply clipping region.
            </summary>
        </member>
        <member name="F:System.Windows.Forms.ApplyGraphicsProperties.TranslateTransform">
            <summary>
             Apply coordinate transformation.
            </summary>
        </member>
        <member name="F:System.Windows.Forms.ApplyGraphicsProperties.All">
            <summary>
             Apply all supported Graphics properties.
            </summary>
        </member>
        <member name="T:System.Windows.Forms.Automation.AutomationLiveSetting">
            <summary>
             Describes the notification characteristics of a particular live region
            </summary>
        </member>
        <member name="F:System.Windows.Forms.Automation.AutomationLiveSetting.Off">
            <summary>
             The element does not send notifications if the content of the live region has changed.
            </summary>
        </member>
        <member name="F:System.Windows.Forms.Automation.AutomationLiveSetting.Polite">
            <summary>
             The element sends non-interruptive notifications if the content of the live region has
             changed. With this setting, UI Automation clients and assistive technologies are expected
             to not interrupt the user to inform of changes to the live region.
            </summary>
        </member>
        <member name="F:System.Windows.Forms.Automation.AutomationLiveSetting.Assertive">
            <summary>
             The element sends interruptive notifications if the content of the live region has changed.
             With this setting, UI Automation clients and assistive technologies are expected to interrupt
             the user to inform of changes to the live region.
            </summary>
        </member>
        <member name="T:System.Windows.Forms.Automation.AutomationNotificationKind">
            <summary>
             Indicates the type of notification when raising the UIA Notification event.
            </summary>
        </member>
        <member name="F:System.Windows.Forms.Automation.AutomationNotificationKind.ItemAdded">
            <summary>
             The current element container has had something added to it that should be presented to the user.
            </summary>
        </member>
        <member name="F:System.Windows.Forms.Automation.AutomationNotificationKind.ItemRemoved">
            <summary>
             The current element has had something removed from inside it that should be presented to the user.
            </summary>
        </member>
        <member name="F:System.Windows.Forms.Automation.AutomationNotificationKind.ActionCompleted">
            <summary>
             The current element has a notification that an action was completed.
            </summary>
        </member>
        <member name="F:System.Windows.Forms.Automation.AutomationNotificationKind.ActionAborted">
            <summary>
             The current element has a notification that an action was abandoned.
            </summary>
        </member>
        <member name="F:System.Windows.Forms.Automation.AutomationNotificationKind.Other">
            <summary>
             The current element has a notification not an add, remove, completed, or aborted action.
            </summary>
        </member>
        <member name="T:System.Windows.Forms.Automation.AutomationNotificationProcessing">
            <summary>
             Specifies the order in which to process a notification.
            </summary>
        </member>
        <member name="F:System.Windows.Forms.Automation.AutomationNotificationProcessing.ImportantAll">
            <summary>
             These notifications should be presented to the user as soon as possible.
             All of the notifications from this source should be delivered to the user.
             Warning:
             Use this in a limited capacity as this style of message could cause a flooding
             for information to the end user due to the nature of the request to deliver all of the notifications.
            </summary>
        </member>
        <member name="F:System.Windows.Forms.Automation.AutomationNotificationProcessing.ImportantMostRecent">
            <summary>
             These notifications should be presented to the user as soon as possible.
             The most recent notifications from this source should be delivered to the user
             because the most recent notification supersedes all of the other notifications.
            </summary>
        </member>
        <member name="F:System.Windows.Forms.Automation.AutomationNotificationProcessing.All">
            <summary>
             These notifications should be presented to the user when possible.
             All of the notifications from this source should be delivered to the user.
            </summary>
        </member>
        <member name="F:System.Windows.Forms.Automation.AutomationNotificationProcessing.MostRecent">
            <summary>
             These notifications should be presented to the user when possible.
             Interrupt the current notification for this one.
            </summary>
        </member>
        <member name="F:System.Windows.Forms.Automation.AutomationNotificationProcessing.CurrentThenMostRecent">
            <summary>
             These notifications should be presented to the user when possible.
             Dont interrupt the current notification for this one.
             If new notifications come in from the same source while the current notification is being presented,
             then keep the most recent and ignore the rest until the current processing is completed.
             Then use the most recent message as the current message.
            </summary>
        </member>
        <member name="T:System.Windows.Forms.DeviceContextExtensions">
            <summary>
             Drawing helpers for device contexts. All methods restore original state unless otherwise specified.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.DeviceContextExtensions.DrawLines(System.Windows.Forms.DeviceContextHdcScope,Interop.Gdi32.HPEN,System.ReadOnlySpan{System.Int32})">
            <summary>
             Draws lines with the <paramref name="hpen"/> using points defined in <paramref name="lines"/>.
            </summary>
            <param name="lines">
             MUST be a mulitple of 4. Each group of 4 represents x1, y1, x2, y2.
            </param>
        </member>
        <member name="M:System.Windows.Forms.DeviceContextExtensions.DrawLines(Interop.Gdi32.HDC,Interop.Gdi32.HPEN,System.ReadOnlySpan{System.Int32})">
            <summary>
             Draws lines with the <paramref name="hpen"/> using points defined in <paramref name="lines"/>.
            </summary>
            <param name="lines">
             MUST be a mulitple of 4. Each group of 4 represents x1, y1, x2, y2.
            </param>
        </member>
        <member name="M:System.Windows.Forms.DeviceContextExtensions.FindNearestColor(Interop.Gdi32.HDC,System.Drawing.Color)">
             <summary>
              Calls <see cref="M:Interop.Gdi32.GetNearestColor(Interop.Gdi32.HDC,System.Int32)"/> to get the nearest color for the given
              <paramref name="color"/>. Returns the original color if the color didn't actually change, retaining
              the state of the color.
             </summary>
             <remarks>
              This is important as the color only changes if <paramref name="hdc"/> is a very low color depth. This
              is extremely rare for the normal case of HDC backed Graphics objects. Keeping the original color keeps the
              state that would otherwise be stripped, notably things like <see cref="P:System.Drawing.Color.IsKnownColor"/> which allows
              us to later pull from a the various caches that <see cref="N:System.Drawing"/> maintains (saving allocations).
            
              Ideally we'd drop checking at all and just support full color drawing to improve performance for the
              expected normal case (more than 8 BITSPIXEL for the HDC).
             </remarks>
        </member>
        <member name="M:System.Windows.Forms.DeviceContextExtensions.TryGetGraphics(System.Drawing.IDeviceContext,System.Boolean)">
            <summary>
             Convert the <paramref name="deviceContext"/> into a <see cref="T:System.Drawing.Graphics"/> object if possible.
            </summary>
            <param name="create">
             Will create the <see cref="T:System.Drawing.Graphics"/> if possible and it is not already created.
            </param>
            <remarks>
             Do NOT dispose of the <see cref="T:System.Drawing.Graphics"/> object. If it was created, the object creating it owns it.
            </remarks>
        </member>
        <member name="T:System.Windows.Forms.DeviceContextHdcScope">
             <summary>
              Helper to scope getting a <see cref="T:Interop.Gdi32.HDC"/> from a <see cref="T:System.Drawing.IDeviceContext"/> object. Releases
              the <see cref="T:Interop.Gdi32.HDC"/> when disposed, unlocking the parent <see cref="T:System.Drawing.IDeviceContext"/> object.
            
              Also saves and restores the state of the HDC.
             </summary>
             <remarks>
              Use in a <see langword="using" /> statement. If you must pass this around, always pass by+
              <see langword="ref" /> to avoid duplicating the handle and risking a double release.
             </remarks>
        </member>
        <member name="M:System.Windows.Forms.DeviceContextHdcScope.#ctor(System.Drawing.IDeviceContext,System.Boolean,System.Boolean)">
             <summary>
              Gets the <see cref="T:Interop.Gdi32.HDC"/> from the the given <paramref name="deviceContext"/>.
             </summary>
             <remarks>
              When a <see cref="T:System.Drawing.Graphics"/> object is created from a <see cref="T:Interop.Gdi32.HDC"/> the clipping region and
              the viewport origin are applied (<see cref="M:Interop.Gdi32.GetViewportExtEx(Interop.Gdi32.HDC,System.Drawing.Size@)"/>). The clipping
              region isn't reflected in <see cref="P:System.Drawing.Graphics.Clip"/>, which is combined with the HDC HRegion.
            
              The Graphics object saves and restores DC state when performing operations that would modify the DC to
              maintain the DC in its original or returned state after <see cref="M:System.Drawing.Graphics.ReleaseHdc"/>.
             </remarks>
             <param name="applyGraphicsState">
              Applies the origin transform and clipping region of the <paramref name="deviceContext"/> if it is an
              object of type <see cref="T:System.Drawing.Graphics"/>. Otherwise this is a no-op.
             </param>
             <param name="saveHdcState">
              When true, saves and restores the <see cref="T:Interop.Gdi32.HDC"/> state.
             </param>
        </member>
        <member name="M:System.Windows.Forms.DeviceContextHdcScope.#ctor(System.Drawing.IDeviceContext,System.Windows.Forms.ApplyGraphicsProperties,System.Boolean)">
            <summary>
             Prefer to use <see cref="M:System.Windows.Forms.DeviceContextHdcScope.#ctor(System.Drawing.IDeviceContext,System.Boolean,System.Boolean)"/>.
            </summary>
            <remarks>
             Ideally we'd not bifurcate what properties we apply unless we're absolutely sure we only want one.
            </remarks>
        </member>
        <member name="T:System.Windows.Forms.FileDialogCustomPlace">
            <remarks>
             Sample Guids
             ComputerFolder: "0AC0837C-BBF8-452A-850D-79D08E667CA7"
             Favorites: "1777F761-68AD-4D8A-87BD-30B759FA33DD"
             Documents: "FDD39AD0-238F-46AF-ADB4-6C85480369C7"
             Profile: "5E6C858F-0E22-4760-9AFE-EA3317B67173"
            </remarks>
        </member>
        <member name="M:System.Windows.Forms.FileDialogCustomPlace.GetNativePath">
            <remarks>
             This can throw in a multitude of ways if the path or Guid doesn't correspond
             to an actual filesystem directory.
             The caller is responsible for handling these situations.
            </remarks>
        </member>
        <member name="T:System.Windows.Forms.GdiPlusCache">
            <summary>
             Cache of GDI+ objects to reuse commonly created items.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.GdiPlusCache.GetCachedPenScope(System.Drawing.Color)">
            <summary>
             Returns a cached <see cref="T:System.Drawing.Pen"/>. Use in a using and assign to var.
            </summary>
            <remarks>
             Correct: using var pen = GdiPlusCache.GetCachedPen(Color.Blue);
             Incorrect (LEAKS): using Pen pen = GdiPlusCache.GetCachedPen(Color.Blue);
            </remarks>
        </member>
        <member name="M:System.Windows.Forms.GdiPlusCache.GetCachedPenScope(System.Drawing.Color,System.Int32)">
             <summary>
              Returns a cached <see cref="T:System.Drawing.Pen"/>. Use in a using and assign to var.
             </summary>
             <remarks>
              Correct: using var pen = GdiPlusCache.GetCachedPen(Color.Blue);
              Incorrect (LEAKS): using Pen pen = GdiPlusCache.GetCachedPen(Color.Blue);
            
              Debug builds track proper disposal.
             </remarks>
        </member>
        <member name="M:System.Windows.Forms.GdiPlusCache.GetCachedSolidBrushScope(System.Drawing.Color)">
             <summary>
              Returns a cached <see cref="T:System.Drawing.SolidBrush"/>. Use in a using and assign to var.
             </summary>
             <remarks>
              Correct: using var pen = GdiPlusCache.GetCachedSolidBrush(Color.Blue);
              Incorrect (LEAKS): using Pen pen = GdiPlusCache.GetCachedSolidBrush(Color.Blue);
            
              Debug builds track proper disposal.
             </remarks>
        </member>
        <member name="T:System.Windows.Forms.GraphicsClipScope">
            <summary>
             Saves and restores <see cref="P:System.Drawing.Graphics.Clip"/>.
            </summary>
        </member>
        <member name="T:System.Windows.Forms.GraphicsStateScope">
            <summary>
             Saves and restores the entire state of a <see cref="T:System.Drawing.Graphics"/>.
            </summary>
        </member>
        <member name="T:System.Windows.Forms.HighDpiMode">
            <summary>
             Specifies the different high DPI modes that can be applied to an application.
            </summary>
            <remarks>
             <para>
             Specifying the high DPI mode is dependent on the OS version of the machine you're running your application on.
             Setting the high DPI mode will work on machines running Windows 10 Creators Update (version 1703) or later versions.
             </para>
             <para>
             Changing the DPI mode while the application is running doesn't impact scaling if you're using the `PerMonitor` value.
             If there is more than one monitor attached and their DPI settings are different, the DPI may change when the window
             is moved from one monitor to the other.
             In this case, the application rescales according to the new monitor's DPI settings.
             Alternatively, the DPI of a window can be changed when the OS scaling setting is changed for the monitor the window is on.
             </para>
            </remarks>
        </member>
        <member name="F:System.Windows.Forms.HighDpiMode.DpiUnaware">
            <summary>
             The window does not scale for DPI changes and always assumes a scale factor of 100%.
            </summary>
        </member>
        <member name="F:System.Windows.Forms.HighDpiMode.SystemAware">
            <summary>
             The window queries for the DPI of the primary monitor once and uses this for the application on all monitors.
            </summary>
        </member>
        <member name="F:System.Windows.Forms.HighDpiMode.PerMonitor">
            <summary>
             The window checks for DPI when it's created and adjusts scale factor when the DPI changes.
            </summary>
        </member>
        <member name="F:System.Windows.Forms.HighDpiMode.PerMonitorV2">
            <summary>
             Similar to <see cref="F:System.Windows.Forms.HighDpiMode.PerMonitor"/>, but enables child window DPI change notification, improved scaling of comctl32 controls and dialog scaling.
            </summary>
        </member>
        <member name="F:System.Windows.Forms.HighDpiMode.DpiUnawareGdiScaled">
            <summary>
             Similar to <see cref="F:System.Windows.Forms.HighDpiMode.DpiUnaware"/>, but improves the quality of GDI/GDI+ based content.
            </summary>
        </member>
        <member name="T:System.Windows.Forms.IGraphicsHdcProvider">
            <summary>
             Used to provide a way to give <see cref="T:System.Windows.Forms.DeviceContextHdcScope"/> direct internal access to HDC's.
            </summary>
        </member>
        <member name="P:System.Windows.Forms.IGraphicsHdcProvider.IsGraphicsStateClean">
            <summary>
             If this flag is true we expect that the <see cref="T:System.Drawing.Graphics"/> object obtained through
             <see cref="M:System.Windows.Forms.IGraphicsHdcProvider.GetGraphics(System.Boolean)"/> should not have a <see cref="T:System.Drawing.Region"/> clip or <see cref="T:System.Drawing.Drawing2D.Matrix"/>
             applied and therefore it is safe to skip getting them via <see cref="M:System.Drawing.Graphics.GetContextInfo"/>.
            </summary>
            <remarks>
             If a <see cref="T:System.Drawing.Graphics"/> object hasn't been created it, by definition, will be clean when it is
             created, so this will return true.
            </remarks>
        </member>
        <member name="M:System.Windows.Forms.IGraphicsHdcProvider.GetHDC">
            <summary>
             Gets the <see cref="T:Interop.Gdi32.HDC"/>, if the object was created from one.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.IGraphicsHdcProvider.GetGraphics(System.Boolean)">
            <summary>
             Get the <see cref="T:System.Drawing.Graphics"/> object.
            </summary>
            <param name="createIfNeeded">
             If true, this will pass back a <see cref="T:System.Drawing.Graphics"/> object, creating a new one *if* needed.
             If false, will pass back a <see cref="T:System.Drawing.Graphics"/> object *if* one exists, otherwise returns null.
            </param>
            <remarks>
             Do not dispose of the returned <see cref="T:System.Drawing.Graphics"/> object.
            </remarks>
        </member>
        <member name="M:System.Windows.Forms.ClientUtils.GetWordBoundaryStart(System.String,System.Int32)">
            <summary>
             Imitates the backwards word selection logic of the native SHAutoComplete Ctrl+Backspace handler.
             The selection will consist of any run of word characters and any run of non-word characters at the end of that word.
             If the selection reaches the second character in the input, and the first character is non-word, it is also selected.
             Here, word characters are equivalent to the "\w" regex class but with UnicodeCategory.ConnectorPunctuation excluded.
            </summary>
        </member>
        <member name="T:System.Windows.Forms.DpiHelper">
            <summary>
             Helper class for scaling coordinates and images according to current DPI scaling set in Windows for the primary screen.
            </summary>
            <summary>
             Partial DpiHelper class, with methods specific to thread DpiAwarenessContext
            </summary>
        </member>
        <member name="P:System.Windows.Forms.DpiHelper.IsPerMonitorV2Awareness">
            <summary>
             Returns a boolean to specify if we should enable processing of WM_DPICHANGED and related messages
            </summary>
        </member>
        <member name="P:System.Windows.Forms.DpiHelper.IsScalingRequirementMet">
            <summary>
             Indicates, if rescaling becomes necessary, either because we are not 96 DPI or we're PerMonitorV2Aware.
            </summary>
        </member>
        <member name="P:System.Windows.Forms.DpiHelper.LogicalToDeviceUnitsScalingFactor">
            <summary>
             Returns the ratio of <see cref="P:System.Windows.Forms.DpiHelper.DeviceDpi"/> to <see cref="F:System.Windows.Forms.DpiHelper.LogicalDpi"/>.
            </summary>
        </member>
        <member name="P:System.Windows.Forms.DpiHelper.IsScalingRequired">
            <summary>
             Returns whether scaling is required when converting between logical-device units,
             if the application opted in the automatic scaling in the .config file.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.DpiHelper.ConvertToGivenDpiPixel(System.Int32,System.Double)">
            <summary>
            scale logical pixel to the factor
            </summary>
        </member>
        <member name="M:System.Windows.Forms.DpiHelper.LogicalToDeviceUnits(System.Int32,System.Int32)">
            <summary>
             Transforms a horizontal or vertical integer coordinate from logical to device units
             by scaling it up for current DPI and rounding to nearest integer value
            </summary>
            <param name="value">value in logical units</param>
            <returns>value in device units</returns>
        </member>
        <member name="M:System.Windows.Forms.DpiHelper.LogicalToDeviceUnits(System.Windows.Forms.Padding,System.Int32)">
            <summary>
             Returns a new Padding with the input's
             dimensions converted from logical units to device units.
            </summary>
            <param name="logicalPadding">Padding in logical units</param>
            <returns>Padding in device units</returns>
        </member>
        <member name="M:System.Windows.Forms.DpiHelper.LogicalToDeviceUnitsX(System.Int32)">
            <summary>
             Transforms a horizontal integer coordinate from logical to device units
             by scaling it up  for current DPI and rounding to nearest integer value
            </summary>
            <param name="value">The horizontal value in logical units</param>
            <returns>The horizontal value in device units</returns>
        </member>
        <member name="M:System.Windows.Forms.DpiHelper.LogicalToDeviceUnitsY(System.Int32)">
            <summary>
             Transforms a vertical integer coordinate from logical to device units
             by scaling it up  for current DPI and rounding to nearest integer value
            </summary>
            <param name="value">The vertical value in logical units</param>
            <returns>The vertical value in device units</returns>
        </member>
        <member name="M:System.Windows.Forms.DpiHelper.LogicalToDeviceUnits(System.Drawing.Size,System.Int32)">
            <summary>
             Returns a new Size with the input's
             dimensions converted from logical units to device units.
            </summary>
            <param name="logicalSize">Size in logical units</param>
            <returns>Size in device units</returns>
        </member>
        <member name="M:System.Windows.Forms.DpiHelper.CreateResizedBitmap(System.Drawing.Bitmap,System.Drawing.Size)">
            <summary>
             Create and return a new bitmap scaled to the specified size.
            </summary>
            <param name="logicalImage">The image to scale from logical units to device units</param>
            <param name="targetImageSize">The size to scale image to</param>
        </member>
        <member name="M:System.Windows.Forms.DpiHelper.GetBitmapFromIcon(System.Type,System.String)">
            <summary>
             Creating bitmap from Icon resource
            </summary>
        </member>
        <member name="M:System.Windows.Forms.DpiHelper.ScaleBitmapLogicalToDevice(System.Drawing.Bitmap@,System.Int32)">
            <summary>
             Create a new bitmap scaled for the device units.
             When displayed on the device, the scaled image will have same size as the original image would have when displayed at 96dpi.
            </summary>
            <param name="logicalBitmap">The image to scale from logical units to device units</param>
        </member>
        <member name="P:System.Windows.Forms.DpiHelper.FirstParkingWindowCreated">
            <summary>
             Indicates whether the first (Parking)Window has been created. From that moment on,
             we will not be able nor allowed to change the Process' DpiMode.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.DpiHelper.GetWinformsApplicationDpiAwareness">
            <summary>
             Gets the DPI awareness.
            </summary>
            <returns>The thread's/process' current HighDpi mode</returns>
        </member>
        <member name="M:System.Windows.Forms.DpiHelper.SetWinformsApplicationDpiAwareness(System.Windows.Forms.HighDpiMode)">
            <summary>
             Sets the DPI awareness. If not available on the current OS, it falls back to the next possible.
            </summary>
            <returns>true/false - If the process DPI awareness is successfully set, returns true. Otherwise false.</returns>
        </member>
        <member name="M:System.Windows.Forms.DpiHelper.EnterDpiAwarenessScope(System.IntPtr)">
            <summary>
             Enters a scope during which the current thread's DPI awareness context is set to
            <paramref name="awareness"/>
            </summary>
            <param name="awareness">The new DPI awareness for the current thread</param>
            <returns>An object that, when disposed, will reset the current thread's
             DPI awareness to the value it had when the object was created.</returns>
        </member>
        <member name="M:System.Windows.Forms.DpiHelper.CreateInstanceInSystemAwareContext``1(System.Func{``0})">
            <summary>
             Create an object in system aware context. This method is mainly designed to create control objects in system aware context.
             class is internal and is mainly used for modal dialogs.
            </summary>
            <typeparam name="T">return type of the object</typeparam>
            <param name="createInstance">lambda expression</param>
            <returns> returns object created in system aware mode</returns>
        </member>
        <member name="T:System.Windows.Forms.DpiHelper.DpiAwarenessScope">
            <summary>
             Class that help setting Dpi awareness context scope
            </summary>
        </member>
        <member name="M:System.Windows.Forms.DpiHelper.DpiAwarenessScope.#ctor(System.IntPtr)">
            <summary>
             Enters given Dpi awareness scope
            </summary>
        </member>
        <member name="M:System.Windows.Forms.DpiHelper.DpiAwarenessScope.Dispose">
            <summary>
             Dispose object and resources
            </summary>
        </member>
        <member name="M:System.Windows.Forms.DpiHelper.DpiAwarenessScope.ResetDpiAwarenessContextChanges">
            <summary>
             resetting dpiawareness of the thread.
            </summary>
        </member>
        <member name="T:System.Windows.Forms.MessageDecoder">
            <summary>
             Decodes Windows messages. This is in a separate class from Message so we can avoid
             loading it in the 99% case where we don't need it.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.MessageDecoder.MsgToString(System.Int32)">
            <summary>
             Returns the symbolic name of the msg value, or null if it isn't one of the
             existing constants.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.NativeMethods.GetLocalPath(System.String)">
            <summary>
             This method takes a file URL and converts it to a local path.  The trick here is that
             if there is a '#' in the path, everything after this is treated as a fragment.  So
             we need to append the fragment to the end of the path.
            </summary>
        </member>
        <member name="P:System.Windows.Forms.OsVersion.IsWindows10_1607OrGreater">
            <summary>
             Is Windows 10 Anniversary Update or later. (Redstone 1, build 14393, version 1607)
            </summary>
        </member>
        <member name="P:System.Windows.Forms.OsVersion.IsWindows10_1703OrGreater">
            <summary>
             Is Windows 10 Creators Update or later. (Redstone 2, build 15063, version 1703)
            </summary>
        </member>
        <member name="P:System.Windows.Forms.OsVersion.IsWindows8_1OrGreater">
            <summary>
             Is Windows 8.1 or later.
            </summary>
        </member>
        <member name="P:System.Windows.Forms.OsVersion.IsWindows8OrGreater">
            <summary>
             Is Windows 8 or later.
            </summary>
        </member>
        <member name="T:System.Windows.Forms.ThemingScope">
            <summary>
             This class provides static methods to create, activate and deactivate the theming scope.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.ThemingScope.IsContextActive">
            <summary>
             We now use explicitactivate everywhere and use this method to determine if we
             really need to activate the activationcontext.  This should be pretty fast.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.ThemingScope.Activate(System.Boolean)">
            <summary>
             Activate() does nothing if a theming context is already active on the current thread, which is good
             for perf reasons. However, in some cases, like in the Timer callback, we need to put another context
             on the stack even if one is already present. In such cases, this method helps - you get to manage
             the cookie yourself though.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.ThemingScope.Deactivate(System.IntPtr)">
            <summary>
             Use this to deactivate a context activated by calling ExplicitActivate.
            </summary>
        </member>
        <member name="T:System.Windows.Forms.WeakRefCollection">
             <summary>
              A collection that holds onto weak references.
            
              Essentially you pass in the object as it is, and under the covers
              we only hold a weak reference to the object.
            
              -----------------------------------------------------------------
              !!!IMPORTANT USAGE NOTE!!!
              Users of this class should set the RefCheckThreshold property
              explicitly or call ScavengeReferences every once in a while to
              remove dead references.
              Also avoid calling Remove(item).  Instead call RemoveByHashCode(item)
              to make sure dead refs are removed.
              -----------------------------------------------------------------
             </summary>
        </member>
        <member name="P:System.Windows.Forms.WeakRefCollection.RefCheckThreshold">
            <summary>
             Indicates the value where the collection should check its items to remove dead weakref left over.
             Note: When GC collects weak refs from this collection the WeakRefObject identity changes since its
             Target becomes null. This makes the item unrecognizable by the collection and cannot be
             removed - Remove(item) and Contains(item) will not find it anymore.
            </summary>
        </member>
        <member name="T:System.Windows.Forms.WeakRefCollection.WeakRefObject">
            <summary>
             Wraps a weak ref object. WARNING: Use this class carefully!
             When the weak ref is collected, this object looses its identity. This is bad when the object
             has been added to a collection since Contains(WeakRef(item)) and Remove(WeakRef(item)) would
             not be able to identify the item.
            </summary>
        </member>
        <member name="T:System.Windows.Forms.Message">
            <summary>
             Implements a Windows message.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.Message.GetLParam(System.Type)">
            <summary>
             Gets the <see cref='P:System.Windows.Forms.Message.LParam'/> value, and converts the value to an object.
            </summary>
        </member>
        <member name="T:System.Windows.Forms.ObjectCache`1">
            <summary>
             Light weight multithreaded fixed size cache class.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.ObjectCache`1.#ctor(System.Int32)">
            <summary>
             Create a cache with space for the specified number of items.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.ObjectCache`1.Acquire">
            <summary>
             Get an item from the cache or create one if none are available.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.ObjectCache`1.Release(`0)">
            <summary>
             Release an item back to the cache, disposing if no room is available.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.Padding.op_Addition(System.Windows.Forms.Padding,System.Windows.Forms.Padding)">
            <summary>
             Performs vector addition of two <see cref='T:System.Windows.Forms.Padding'/> objects.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.Padding.op_Subtraction(System.Windows.Forms.Padding,System.Windows.Forms.Padding)">
            <summary>
             Contracts a <see cref='T:System.Drawing.Size'/> by another <see cref='T:System.Drawing.Size'/>.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.Padding.op_Equality(System.Windows.Forms.Padding,System.Windows.Forms.Padding)">
            <summary>
             Tests whether two <see cref='T:System.Windows.Forms.Padding'/> objects are identical.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.Padding.op_Inequality(System.Windows.Forms.Padding,System.Windows.Forms.Padding)">
            <summary>
             Tests whether two <see cref='T:System.Windows.Forms.Padding'/> objects are different.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.PaddingConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <summary>
             Determines if this converter can convert an object in the given source type to
             the native type of the converter.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.PaddingConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <summary>
             Converts the given object to the converter's native type.
            </summary>
        </member>
        <member name="T:System.Windows.Forms.RefCountedCache`3">
            <summary>
             Cache that ref counts handed-out objects via "scopes" <see cref="T:System.Windows.Forms.RefCountedCache`3.Scope"/>.
            </summary>
            <typeparam name="TObject">
             The target object the cache represents. If you're caching <see cref="T:System.Drawing.Pen"/> that would be the
             type you would use here. <see cref="T:System.Windows.Forms.RefCountedCache`3.Scope"/> is implicitly convertable to this type.
            </typeparam>
            <typeparam name="TCacheEntryData">
             The type of data to associate with a cache entry. For a simple cache this can be the same type as
             <typeparamref name="TKey"/>.
            </typeparam>
            <typeparam name="TKey">
             The type of key used to look up cache entries.
            </typeparam>
        </member>
        <member name="T:System.Windows.Forms.RefCountedCache`3.CacheEntry">
            <summary>
             Cache entry that maintains the reference count, entry data, and basic cleanup logic.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.RefCountedCache`3.CacheEntry.AddRef">
            <summary>
             Add a reference to this entry.
            </summary>
        </member>
        <member name="P:System.Windows.Forms.RefCountedCache`3.CacheEntry.RefCount">
            <summary>
             Current reference count for this entry.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.RefCountedCache`3.CacheEntry.RemoveRef">
            <summary>
             Removes a reference to this entry.
            </summary>
            <remarks>
             This will dispose of the entry when the ref count reaches zero- if the entry isn't actually
             cached <see cref="F:System.Windows.Forms.RefCountedCache`3.CacheEntry._cached"/>.
            </remarks>
        </member>
        <member name="P:System.Windows.Forms.RefCountedCache`3.CacheEntry.Object">
            <summary>
             Implement this to provide the target object for users.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.RefCountedCache`3.CacheEntry.Dispose(System.Boolean)">
            <summary>
             By default we dispose of <see cref="P:System.Windows.Forms.RefCountedCache`3.CacheEntry.Data"/> and <see cref="P:System.Windows.Forms.RefCountedCache`3.CacheEntry.Object"/> if they implement
             <see cref="T:System.IDisposable" />. Override to provide custom cleanup logic.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:System.Windows.Forms.RefCountedCache`3.CreateEntry(`2,System.Boolean)">
            <summary>
             Override this to create a new <see cref="T:System.Windows.Forms.RefCountedCache`3.CacheEntry"/> for the given <paramref name="key"/>.
            </summary>
            <param name="cached">
             True if the entry is actually kept in the cache. When the cache hits the hard limit entries aren't
             kept in the cache and need to be cleaned up when the ref count drops to zero.
            </param>
        </member>
        <member name="M:System.Windows.Forms.RefCountedCache`3.IsMatch(`2,System.Windows.Forms.RefCountedCache{`0,`1,`2}.CacheEntry)">
            <summary>
             Return true if the given <paramref name="key"/> matches the given <paramref name="entry"/>.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.RefCountedCache`3.GetEntry(`2)">
            <summary>
             Find or create the entry for <paramref name="key"/>.
            </summary>
            <remarks>
             Override if you want to modify behavior or lock cache access.
            </remarks>
        </member>
        <member name="T:System.Windows.Forms.RefCountedCache`3.Scope">
            <summary>
             Disposable struct that manages reference counting of <see cref="T:System.Windows.Forms.RefCountedCache`3.CacheEntry"/>.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.RefCountedCache`3.Scope.#ctor(`0)">
             <summary>
              Constructor to hold an uncached object. Used to wrap something not coming from the cache in a scope
              so it can be abstracted for the end users of a given API.
            
              <see cref="M:System.Windows.Forms.GdiPlusCache.GetSolidBrushScope(System.Drawing.Color)"/> for an example.
             </summary>
             <remarks>
              Currently we don't dispose the <paramref name="object"/> as we don't need to in our usages. If this
              becomes necessary we can add a bool to track whether or not we should dispose it.
             </remarks>
        </member>
        <member name="M:System.Windows.Forms.RefCountedCache`3.Scope.op_Implicit(System.Windows.Forms.RefCountedCache{`0,`1,`2}.Scope@)~`0">
            <summary>
             Implicit conversion to the "target" type, i.e. <typeparamref name="TObject"/>.
            </summary>
            <remarks>
             This is somewhat dangerous as implicit casting in the using statement will leak the scope. Not doing
             this, however, makes usage with APIs difficult. We track in DEBUG to catch misuse as a mitigation.
            </remarks>
        </member>
        <member name="T:System.Windows.Forms.ScreenOrientation">
            <summary>
             Specifies the angle of screen orientation
            </summary>
        </member>
        <member name="F:System.Windows.Forms.ScreenOrientation.Angle0">
            <summary>
             The screen is oriented at 0 degrees
            </summary>
        </member>
        <member name="F:System.Windows.Forms.ScreenOrientation.Angle90">
            <summary>
             The screen is oriented at 90 degrees
            </summary>
        </member>
        <member name="F:System.Windows.Forms.ScreenOrientation.Angle180">
            <summary>
             The screen is oriented at 180 degrees.
            </summary>
        </member>
        <member name="F:System.Windows.Forms.ScreenOrientation.Angle270">
            <summary>
             The screen is oriented at 270 degrees.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.SinglyLinkedList`1.Enumerator.Reset">
            <summary>
             Resets the enumerator.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.SinglyLinkedList`1.Enumerator.MoveNext">
            <summary>
             Attempts to move to the next node. Sets <see cref="P:System.Windows.Forms.SinglyLinkedList`1.Enumerator.Current"/> when successful. If there are no more
             nodes returns false and <see cref="P:System.Windows.Forms.SinglyLinkedList`1.Enumerator.Current"/> will be null.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.SinglyLinkedList`1.Enumerator.RemoveCurrent">
            <summary>
             Removes the <see cref="P:System.Windows.Forms.SinglyLinkedList`1.Enumerator.Current"/> node. Note that this will make <see cref="P:System.Windows.Forms.SinglyLinkedList`1.Enumerator.Current"/> the prior node
             so that <see cref="M:System.Windows.Forms.SinglyLinkedList`1.Enumerator.MoveNext"/> will place on the next node (if any).
            </summary>
            <exception cref="T:System.InvalidOperationException">
             Thrown if attempting to remove without successfully calling <see cref="M:System.Windows.Forms.SinglyLinkedList`1.Enumerator.MoveNext"/>. Will also
             throw if <see cref="M:System.Windows.Forms.SinglyLinkedList`1.Enumerator.RemoveCurrent"/> or <see cref="M:System.Windows.Forms.SinglyLinkedList`1.Enumerator.MoveCurrentToFront"/> is called more than once
             without calling <see cref="M:System.Windows.Forms.SinglyLinkedList`1.Enumerator.MoveNext"/>.
            </exception>
        </member>
        <member name="M:System.Windows.Forms.SinglyLinkedList`1.Enumerator.MoveCurrentToFront">
            <summary>
             Moves the <see cref="P:System.Windows.Forms.SinglyLinkedList`1.Enumerator.Current"/> node to the front of the list. Note that this will make
             <see cref="P:System.Windows.Forms.SinglyLinkedList`1.Enumerator.Current"/> the prior node so that <see cref="M:System.Windows.Forms.SinglyLinkedList`1.Enumerator.MoveNext"/> will place on the next node
             (if any).
            </summary>
            <exception cref="T:System.InvalidOperationException">
             Thrown if attempting to move without successfully calling <see cref="M:System.Windows.Forms.SinglyLinkedList`1.Enumerator.MoveNext"/>. Will also
             throw if <see cref="M:System.Windows.Forms.SinglyLinkedList`1.Enumerator.RemoveCurrent"/> or <see cref="M:System.Windows.Forms.SinglyLinkedList`1.Enumerator.MoveCurrentToFront"/> is called more than once
             without calling <see cref="M:System.Windows.Forms.SinglyLinkedList`1.Enumerator.MoveNext"/>.
            </exception>
        </member>
        <member name="M:System.Windows.Forms.SystemDrawingExtensions.FindNearestColor(System.Drawing.Graphics,System.Drawing.Color)">
             <summary>
              Similar to <see cref="M:System.Drawing.Graphics.GetNearestColor(System.Drawing.Color)"/>, but this retains the original color if the color
              didn't actually change. This retains the state of the color.
             </summary>
             <remarks>
              This is important as the color only changes if <paramref name="graphics"/> has a very low color depth. This
              is extremely rare for the normal case of HDC backed Graphics objects. Keeping the original color keeps the
              state that would otherwise be stripped, notably things like <see cref="P:System.Drawing.Color.IsKnownColor"/> which allows
              us to later pull from a the various caches that <see cref="N:System.Drawing"/> maintains (saving allocations).
            
              Ideally we'd drop checking at all and just support full color drawing to improve performance for the
              expected normal case (more than 8 BITSPIXEL for the HDC).
             </remarks>
        </member>
        <member name="M:System.Windows.Forms.SystemDrawingExtensions.HasTransparency(System.Drawing.Color)">
            <summary>
             Returns true if the color has any transparency. If false, the color is fully opaque.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.SystemDrawingExtensions.IsFullyTransparent(System.Drawing.Color)">
            <summary>
             Returns true if the color is fully transparent.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.SystemDrawingExtensions.DrawLines(System.Drawing.Graphics,System.Drawing.Pen,System.ReadOnlySpan{System.Int32})">
            <summary>
             Draws lines with the <paramref name="pen"/> using points defined in <paramref name="lines"/>.
            </summary>
            <param name="lines">
             MUST be a mulitple of 4. Each group of 4 represents x1, y1, x2, y2.
            </param>
        </member>
        <member name="M:System.Windows.Forms.SystemDrawingExtensions.MixColor(System.Drawing.Color,System.Drawing.Color)">
            <summary>
             Mixes two colors.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.SystemDrawingExtensions.InvertColor(System.Drawing.Color)">
            <summary>
             Inverts the color.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.SystemDrawingExtensions.CreateStaticPen(System.Drawing.Color,System.Drawing.Drawing2D.DashStyle,System.Single)">
            <summary>
             Creates a <see cref="T:System.Drawing.Pen"/>. If <paramref name="color"/> is a system color, makes a static copy of the
             current color value to avoid having the pen hook itself against <see cref="T:Microsoft.Win32.SystemEvents"/>.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.SystemDrawingExtensions.CreateStaticPen(System.Drawing.Brush,System.Single)">
            <summary>
             Not strictly needed (yet), but allows using the same pattern for all pens.
            </summary>
        </member>
        <member name="M:System.Windows.Forms.SystemDrawingExtensions.CreateStaticBrush(System.Drawing.Color)">
            <summary>
             Creates a <see cref="T:System.Drawing.SolidBrush"/>. If <paramref name="color"/> is a system color, makes a static copy of
             the current color value to avoid having the pen hook itself against <see cref="T:Microsoft.Win32.SystemEvents"/>.
            </summary>
        </member>
        <member name="P:System.Windows.Forms.Primitives.Resources.SR.COM2UnhandledVT">
            <summary>Unhandled VT: {0}.</summary>
        </member>
        <member name="P:System.Windows.Forms.Primitives.Resources.SR.TextParseFailedFormat">
            <summary>Parse of Text("{0}") expected text in the format "{1}" did not succeed.</summary>
        </member>
        <member name="P:System.Windows.Forms.Primitives.Resources.SR.PropertyValueInvalidEntry">
            <summary>One or more entries are not valid in the IDictionary parameter. Verify that all values match up to the object's properties.</summary>
        </member>
        <member name="T:System.EasyPoint">
            <summary>
             Simple immutable, intermediary, struct that allows creating point data via tuple: (12, 6).
            </summary>
        </member>
        <member name="M:System.DisposalTracking.SuppressFinalize(System.Object)">
             <summary>
              Used to suppress finalization in debug builds only.
             </summary>
             <remarks>
              Unfortunately this can only be used when there is a single implicit conversion operator when called from
              a ref struct. C# tries to cast to anything that fits in object, which leads to an ambiguous error.
            
              You need to add GC.SuppressFinalize under #ifdef when you don't have a single implicit conversion.
             </remarks>
        </member>
        <member name="T:System.DisposalTracking.Tracker">
             <summary>
              Helper base class for tracking undisposed objects.
             </summary>
             <remarks>
              Fires if <see cref="M:System.GC.SuppressFinalize(System.Object)"/> is not called on the class and the class is finalized.
              As such you must suppress finalization when disposing to "signal" that you've been disposed properly.
            
              The debug only static <see cref="M:System.DisposalTracking.SuppressFinalize(System.Object)"/> can be called when you only derive from this
              class in debug builds.
             </remarks>
        </member>
        <member name="M:System.SpanHelpers.CopyAndTerminate(System.ReadOnlySpan{System.Char},System.Span{System.Char})">
            <summary>
             Copies the <paramref name="source"/> to the <paramref name="destination"/>,
             terminating with null and truncating <paramref name="source"/> to fit if
             necessary.
            </summary>
        </member>
        <member name="M:System.SpanHelpers.SliceAtFirstNull(System.ReadOnlySpan{System.Char})">
            <summary>
             Slices the given <paramref name="span"/> at the first null found (if any).
            </summary>
        </member>
        <member name="M:System.SpanHelpers.SliceAtFirstNull(System.Span{System.Char})">
            <summary>
             Slices the given <paramref name="span"/> at the first null found (if any).
            </summary>
        </member>
        <member name="T:TrailingArray`1">
            <summary>
            Used for trailing native unsized (ANYSIZE) arrays of <typeparamref name="T"/>. Native example:
            UCHAR  UniqueId[1];
            </summary>
            <remarks>
            Accessing the values is only safe when you have a pointer to the containing struct in
            a buffer. If you have an actual struct (Foo, not Foo*), the trailing array will have been
            truncated as the values aren't actually part of the struct.
            </remarks>
        </member>
        <member name="M:WMExtensions.IsBetween(System.Windows.Forms.Message@,Interop.User32.WM,Interop.User32.WM)">
            <summary>
            Returns true if the message is between <paramref name="firstMessage"/> and
            <paramref name="secondMessage"/>, inclusive.
            </summary>
        </member>
        <member name="M:WMExtensions.IsBetween(Interop.User32.MSG@,Interop.User32.WM,Interop.User32.WM)">
            <summary>
            Returns true if the message is between <paramref name="firstMessage"/> and
            <paramref name="secondMessage"/>, inclusive.
            </summary>
        </member>
    </members>
</doc>
